<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft-Inspired 3D World</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
        }

        #ui button {
            background: rgba(255, 255, 255, 0.7);
            border: 2px solid #555;
            border-radius: 5px;
            padding: 8px 15px;
            margin-right: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        #ui button:hover {
            background: rgba(255, 255, 255, 0.9);
        }

        #ui button.active {
            background: rgba(100, 255, 100, 0.7);
        }

        #blockSelector {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            color: white;
        }

        #blockSelector div {
            margin: 10px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            padding: 5px;
            border-radius: 5px;
        }

        #blockSelector div:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #blockSelector div.selected {
            background: rgba(255, 255, 255, 0.3);
        }

        .block-preview {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            border: 1px solid #888;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }

        #crosshair::before, #crosshair::after {
            content: "";
            position: absolute;
            background: white;
        }

        #crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #crosshair::after {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #instructions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 1000;
        }

        #instructions button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            margin-top: 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
        }

        #timeDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }

        /* Crafting system styles */
        #craftingUI {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 400px;
            background: rgba(50, 50, 50, 0.9);
            border: 3px solid #555;
            border-radius: 8px;
            padding: 20px;
            display: none;
            z-index: 2000;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #craftingGrid {
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 80px);
            gap: 5px;
            margin: 0 auto 20px;
            width: 250px;
        }

        .craftingSlot {
            width: 80px;
            height: 80px;
            background: rgba(80, 80, 80, 0.7);
            border: 2px solid #777;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }

        .craftingSlot:hover {
            background: rgba(100, 100, 100, 0.7);
        }

        .craftingSlot.filled {
            background: rgba(120, 120, 120, 0.7);
        }

        .resultSlot {
            width: 100px;
            height: 100px;
            background: rgba(60, 110, 60, 0.7);
            border: 2px solid #5a5;
            margin: 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #inventoryGrid {
            display: grid;
            grid-template-columns: repeat(5, 60px);
            gap: 5px;
            margin-top: 20px;
        }

        .inventorySlot {
            width: 60px;
            height: 60px;
            background: rgba(80, 80, 80, 0.7);
            border: 2px solid #777;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }

        .inventorySlot:hover {
            background: rgba(100, 100, 100, 0.7);
        }

        .slotItem {
            width: 40px;
            height: 40px;
            border-radius: 5px;
        }

        .slotQuantity {
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
        }

        #craftingButtons {
            display: flex;
            justify-content: center;
            margin-top: 15px;
        }

        #craftingButtons button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
        }

        #craftingButtons button:hover {
            background: #3e8e41;
        }

        #craftingButtons button:disabled {
            background: #888;
            cursor: not-allowed;
        }

        #inventoryDisplay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .invItem {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .invIcon {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>Minecraft-Inspired 3D World</h1>
        <p>Use WASD to move, SPACE to jump, MOUSE to look around</p>
        <p>LEFT CLICK to remove blocks, RIGHT CLICK to place blocks</p>
        <p>Select different block types from the menu on the right</p>
        <p>Choose biomes using the buttons at the bottom</p>
        <button id="startButton">Start Game</button>
    </div>

    <div id="crosshair"></div>

    <div id="timeDisplay">Time: Day</div>

    <div id="ui">
        <button class="biome-btn active" data-biome="forest">Forest</button>
        <button class="biome-btn" data-biome="desert">Desert</button>
        <button class="biome-btn" data-biome="mountains">Mountains</button>
        <button class="biome-btn" data-biome="plains">Plains</button>
    </div>

    <div id="blockSelector">
        <h3>Block Types</h3>
        <div class="block-type selected" data-type="grass">
            <div class="block-preview" style="background-color: #5D9E47;"></div>
            <span>Grass</span>
        </div>
        <div class="block-type" data-type="dirt">
            <div class="block-preview" style="background-color: #8B5A2B;"></div>
            <span>Dirt</span>
        </div>
        <div class="block-type" data-type="stone">
            <div class="block-preview" style="background-color: #888888;"></div>
            <span>Stone</span>
        </div>
        <div class="block-type" data-type="sand">
            <div class="block-preview" style="background-color: #E2D9A2;"></div>
            <span>Sand</span>
        </div>
        <div class="block-type" data-type="wood">
            <div class="block-preview" style="background-color: #8B4513;"></div>
            <span>Wood</span>
        </div>
    </div>

    <!-- Crafting Interface -->
    <div id="craftingUI">
        <h2 style="text-align: center; margin-top: 0;">Crafting</h2>
        
        <div id="craftingGrid">
            <!-- 3x3 crafting grid, will be populated by JavaScript -->
        </div>
        
        <div class="resultSlot" id="resultSlot">
            <!-- Result will appear here -->
        </div>
        
        <div id="craftingButtons">
            <button id="craftBtn" disabled>Craft</button>
            <button id="clearBtn">Clear</button>
            <button id="closeCraftingBtn">Close</button>
        </div>
        
        <h3 style="margin-top: 20px;">Inventory</h3>
        <div id="inventoryGrid">
            <!-- Inventory slots will be populated by JavaScript -->
        </div>
    </div>

    <!-- Simple Inventory Display (always visible) -->
    <div id="inventoryDisplay">
        <!-- Will be populated with current inventory -->
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let terrain = {}, worldSize = 16, chunkSize = 16, viewDistance = 2;
        let chunkLoadingQueue = []; // Queue for chunks to be loaded
        let processingChunk = false; // Flag to track if we're currently processing a chunk
        let playerDirection = new THREE.Vector3(); // Track player movement direction for predictive loading
        let previousPlayerPosition = new THREE.Vector3(); // Previous player position for direction calculation
        let lastDirectionUpdateTime = 0; // Time tracking for direction updates
        let chunkRenderDistance = {
            minimum: 1,  // Minimum render distance (closest to player)
            ideal: 2,    // Standard render distance
            maximum: 3,  // Maximum render distance (for pre-loading)
            preloadFar: 4 // Distance to load low-detail chunks ahead of player
        };
        let chunkCache = {}; // Cache for storing chunk data even when not visible
        let maxCachedChunks = 500; // Maximum number of chunks to keep in cache
        let chunkModifications = {}; // Track player modifications to chunks
        let player = { 
            position: new THREE.Vector3(0, 100, 0), // Start at a safe height
            velocity: new THREE.Vector3(0, 0, 0),
            lastChunkX: 0,
            lastChunkZ: 0,
            spawnHeight: 100, // Safe initial height
            isSpawning: true, // Flag to indicate initial spawn
            spawned: false, // Flag to track if player has safely spawned
            lastGlobalX: null,
            lastGlobalZ: null
        };
        let keyboard = {};
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let clock = new THREE.Clock();
        let blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        let selectedBlockType = 'grass';
        let currentBiome = 'forest';
        let dayNightCycle = { time: 0, duration: 300, isDay: true }; // 5 minutes per cycle
        let isGameStarted = false;
        let simplex = new SimplexNoise();
        
        // Audio elements
        let ambientSounds = {
            forest: new Audio('https://freesound.org/data/previews/462/462087_8386274-lq.mp3'),
            desert: new Audio('https://freesound.org/data/previews/361/361259_4284968-lq.mp3'),
            mountains: new Audio('https://freesound.org/data/previews/352/352149_43962-lq.mp3'),
            plains: new Audio('https://freesound.org/data/previews/211/211545_3267529-lq.mp3')
        };
        
        // Block textures and materials with improved colors for realism and contrast
        const blockMaterials = {
            grass: new THREE.MeshLambertMaterial({ color: 0x3A9D23 }), // Vibrant natural green
            dirt: new THREE.MeshLambertMaterial({ color: 0x59472B }), // Rich earth brown
            stone: new THREE.MeshLambertMaterial({ color: 0x666666 }), // Medium gray
            sand: new THREE.MeshLambertMaterial({ color: 0xDBC681 }), // Base desert sand
            sand_light: new THREE.MeshLambertMaterial({ color: 0xE8D9A0 }), // Light sand for dune tops
            sand_red: new THREE.MeshLambertMaterial({ color: 0xC2A477 }), // Reddish sand
            sand_gold: new THREE.MeshLambertMaterial({ color: 0xD4B16A }), // Golden sand
            sand_dark: new THREE.MeshLambertMaterial({ color: 0xB49B6C }), // Darker sand for shadowed areas
            wood: new THREE.MeshLambertMaterial({ color: 0x52341D }), // Dark brown wood
            snow: new THREE.MeshLambertMaterial({ color: 0xF5F5F5 }), // Bright white snow
            water: new THREE.MeshLambertMaterial({ color: 0x1A45A5, transparent: true, opacity: 0.8 }), // Deep blue water
            cactus: new THREE.MeshLambertMaterial({ color: 0x2D742F }) // Dark green cactus
        };
        
        // Crafting system variables
        let playerInventory = {
            grass: 0,
            dirt: 0,
            stone: 0,
            sand: 0,
            wood: 0,
            stick: 0,
            wooden_pickaxe: 0,
            stone_pickaxe: 0,
            wooden_axe: 0,
            stone_axe: 0,
            crafting_table: 0
        };
        
        let craftingGrid = [
            [null, null, null],
            [null, null, null],
            [null, null, null]
        ];
        
        let isCraftingOpen = false;
        let currentRecipeResult = null;
        let selectedInventorySlot = null;
        
        // Recipe definitions
        const recipes = [
            {
                id: "stick",
                pattern: [
                    [null, null, null],
                    [null, "wood", null],
                    [null, "wood", null]
                ],
                result: { item: "stick", quantity: 4 }
            },
            {
                id: "wooden_pickaxe",
                pattern: [
                    ["wood", "wood", "wood"],
                    [null, "stick", null],
                    [null, "stick", null]
                ],
                result: { item: "wooden_pickaxe", quantity: 1 }
            },
            {
                id: "wooden_axe",
                pattern: [
                    ["wood", "wood", null],
                    ["wood", "stick", null],
                    [null, "stick", null]
                ],
                result: { item: "wooden_axe", quantity: 1 }
            },
            {
                id: "stone_pickaxe",
                pattern: [
                    ["stone", "stone", "stone"],
                    [null, "stick", null],
                    [null, "stick", null]
                ],
                result: { item: "stone_pickaxe", quantity: 1 }
            },
            {
                id: "stone_axe",
                pattern: [
                    ["stone", "stone", null],
                    ["stone", "stick", null],
                    [null, "stick", null]
                ],
                result: { item: "stone_axe", quantity: 1 }
            },
            {
                id: "crafting_table",
                pattern: [
                    ["wood", "wood", null],
                    ["wood", "wood", null],
                    [null, null, null]
                ],
                result: { item: "crafting_table", quantity: 1 }
            }
        ];
        
        // Item display properties (colors, names, etc.)
        const itemProperties = {
            grass: { color: "#3A9D23", name: "Grass Block" },
            dirt: { color: "#59472B", name: "Dirt" },
            stone: { color: "#666666", name: "Stone" },
            sand: { color: "#DBC681", name: "Sand" },
            water: { color: "#1E90FF", name: "Water" },
            wood: { color: "#52341D", name: "Wood" },
            stick: { 
                color: "#8B5A2B", 
                name: "Stick",
                render: function(element) {
                    element.style.backgroundColor = "#8B5A2B";
                    element.style.width = "15px";
                    element.style.height = "35px";
                    element.style.margin = "auto";
                }
            },
            wooden_pickaxe: { 
                color: "#8B4513", 
                name: "Wooden Pickaxe",
                render: function(element) {
                    // Create pickaxe head
                    const head = document.createElement('div');
                    head.style.width = "30px";
                    head.style.height = "10px";
                    head.style.backgroundColor = "#8B4513";
                    head.style.position = "absolute";
                    head.style.top = "5px";
                    head.style.left = "50%";
                    head.style.transform = "translateX(-50%)";
                    
                    // Create handle
                    const handle = document.createElement('div');
                    handle.style.width = "6px";
                    handle.style.height = "25px";
                    handle.style.backgroundColor = "#8B5A2B";
                    handle.style.position = "absolute";
                    handle.style.top = "15px";
                    handle.style.left = "50%";
                    handle.style.transform = "translateX(-50%)";
                    
                    element.innerHTML = '';
                    element.appendChild(head);
                    element.appendChild(handle);
                    element.style.position = "relative";
                }
            },
            stone_pickaxe: { 
                color: "#808080", 
                name: "Stone Pickaxe",
                render: function(element) {
                    // Create pickaxe head
                    const head = document.createElement('div');
                    head.style.width = "30px";
                    head.style.height = "10px";
                    head.style.backgroundColor = "#808080";
                    head.style.position = "absolute";
                    head.style.top = "5px";
                    head.style.left = "50%";
                    head.style.transform = "translateX(-50%)";
                    
                    // Create handle
                    const handle = document.createElement('div');
                    handle.style.width = "6px";
                    handle.style.height = "25px";
                    handle.style.backgroundColor = "#8B5A2B";
                    handle.style.position = "absolute";
                    handle.style.top = "15px";
                    handle.style.left = "50%";
                    handle.style.transform = "translateX(-50%)";
                    
                    element.innerHTML = '';
                    element.appendChild(head);
                    element.appendChild(handle);
                    element.style.position = "relative";
                }
            },
            wooden_axe: { 
                color: "#8B4513", 
                name: "Wooden Axe",
                render: function(element) {
                    // Create axe head
                    const head = document.createElement('div');
                    head.style.width = "20px";
                    head.style.height = "20px";
                    head.style.backgroundColor = "#8B4513";
                    head.style.position = "absolute";
                    head.style.top = "2px";
                    head.style.left = "60%";
                    head.style.clipPath = "polygon(0% 50%, 50% 0%, 100% 50%, 50% 100%)";
                    
                    // Create handle
                    const handle = document.createElement('div');
                    handle.style.width = "6px";
                    handle.style.height = "30px";
                    handle.style.backgroundColor = "#8B5A2B";
                    handle.style.position = "absolute";
                    handle.style.top = "10px";
                    handle.style.left = "40%";
                    handle.style.transform = "rotate(45deg)";
                    
                    element.innerHTML = '';
                    element.appendChild(handle);
                    element.appendChild(head);
                    element.style.position = "relative";
                }
            },
            stone_axe: { 
                color: "#808080", 
                name: "Stone Axe",
                render: function(element) {
                    // Create axe head
                    const head = document.createElement('div');
                    head.style.width = "20px";
                    head.style.height = "20px";
                    head.style.backgroundColor = "#808080";
                    head.style.position = "absolute";
                    head.style.top = "2px";
                    head.style.left = "60%";
                    head.style.clipPath = "polygon(0% 50%, 50% 0%, 100% 50%, 50% 100%)";
                    
                    // Create handle
                    const handle = document.createElement('div');
                    handle.style.width = "6px";
                    handle.style.height = "30px";
                    handle.style.backgroundColor = "#8B5A2B";
                    handle.style.position = "absolute";
                    handle.style.top = "10px";
                    handle.style.left = "40%";
                    handle.style.transform = "rotate(45deg)";
                    
                    element.innerHTML = '';
                    element.appendChild(handle);
                    element.appendChild(head);
                    element.style.position = "relative";
                }
            },
            crafting_table: { 
                color: "#7D5A1A", 
                name: "Crafting Table",
                render: function(element) {
                    // Create grid pattern
                    element.style.backgroundImage = "linear-gradient(#8B5A2B 1px, transparent 1px), linear-gradient(90deg, #8B5A2B 1px, transparent 1px)";
                    element.style.backgroundSize = "10px 10px";
                    element.style.backgroundColor = "#7D5A1A";
                }
            }
        };
        
        // Global variables section - add this variable
        let highlightBox;
        
        // Find a safe spawn point in the current biome
        function findSafeSpawnPoint() {
            console.log("Finding safe spawn point in biome:", currentBiome);
            
            // Define safe spawn areas for each biome
            let spawnAreaX = 0; 
            let spawnAreaZ = 0;
            
            switch(currentBiome) {
                case 'desert':
                    spawnAreaX = 16;
                    spawnAreaZ = 16;
                    break;
                case 'mountains':
                    // For mountains, spawn in a lower-elevation valley area
                    spawnAreaX = 24;
                    spawnAreaZ = 24;
                    break;
                case 'plains':
                    spawnAreaX = 8;
                    spawnAreaZ = 8;
                    break;
                case 'forest':
                default:
                    spawnAreaX = 12;
                    spawnAreaZ = 12;
                    break;
            }
            
            // For mountains, find a lower area to spawn
            if (currentBiome === 'mountains') {
                // Scan several positions to find a good valley to spawn in
                let bestHeight = 999;
                let bestX = spawnAreaX;
                let bestZ = spawnAreaZ;
                
                // Try different spots within a region
                for (let xOffset = -8; xOffset <= 8; xOffset += 2) {
                    for (let zOffset = -8; zOffset <= 8; zOffset += 2) {
                        const testX = spawnAreaX + xOffset;
                        const testZ = spawnAreaZ + zOffset;
                        const height = getTerrainHeight(testX, testZ, currentBiome);
                        
                        // Look for a lower spot to avoid spawning on peaks
                        if (height < bestHeight) {
                            bestHeight = height;
                            bestX = testX;
                            bestZ = testZ;
                        }
                    }
                }
                
                spawnAreaX = bestX;
                spawnAreaZ = bestZ;
            }
            
            // Find surface height at spawn location
            const height = getTerrainHeight(spawnAreaX, spawnAreaZ, currentBiome);
            
            // Set player position to safe height above terrain
            player.position.set(spawnAreaX, height + 5, spawnAreaZ);
            player.spawnHeight = height + 5;
            
            console.log(`Safe spawn point found at (${spawnAreaX}, ${height + 5}, ${spawnAreaZ})`);
            
            // Update last chunk position to trigger terrain generation
            player.lastChunkX = Math.floor(player.position.x / chunkSize);
            player.lastChunkZ = Math.floor(player.position.z / chunkSize);
            
            // Update camera position
            if (camera) {
                camera.position.copy(player.position);
                camera.position.y += 1.7; // Eye height
            }
            
            return true;
        }
        
        // Get terrain height based on biome with improved realism
        function getTerrainHeight(x, z, biome) {
            // Use deterministic noise with fixed seed
            // We'll use a different frequency for each biome but keep coordinates consistent
            const scale1 = biome === 'mountains' ? 0.02 : 0.01;
            const scale2 = biome === 'plains' ? 0.03 : 0.05;
            const scale3 = 0.002;
            
            // Make sure to use absolute coordinates that don't depend on player position
            // This prevents terrain from "moving"
            switch (biome) {
                case 'desert':
                    return 7 + Math.floor(8 * (
                        0.8 * simplex.noise2D(x * 0.01, z * 0.01) +
                        0.2 * simplex.noise2D(x * 0.05, z * 0.05) * 
                        Math.pow(Math.abs(simplex.noise2D(x * 0.002, z * 0.002)), 0.7)
                    ));
                    
                case 'mountains':
                    // More dramatic mountain terrain with higher peaks and deeper valleys
                    const baseElevation = 20; // Higher base elevation for mountains
                    const ridgeNoise = Math.pow(Math.abs(simplex.noise2D(x * 0.005, z * 0.005)), 0.8); // Ridge formations
                    const detailNoise = 
                        0.6 * simplex.noise2D(x * 0.03, z * 0.03) + 
                        0.4 * simplex.noise2D(x * 0.08, z * 0.08); // Small details
                    const peakiness = Math.pow(Math.abs(simplex.noise2D(x * 0.001, z * 0.001)), 0.3); // Controls how sharp peaks are
                    
                    const mountainHeight = baseElevation + Math.floor(60 * ridgeNoise * peakiness * (0.8 + 0.4 * detailNoise));
                    return mountainHeight;
                    
                case 'plains':
                    // Check for river path using noise
                    const riverNoise = simplex.noise2D(x * 0.02, z * 0.02);
                    const riverChannel = Math.abs(riverNoise);
                    
                    // River path when riverChannel is small
                    if (riverChannel < 0.05) {
                        return 8; // River level
                    }
                    
                    // Riverbank when close to the river
                    if (riverChannel < 0.12) {
                        return 9 + Math.floor(riverChannel * 20); // Sloping riverbank
                    }
                    
                    // Normal plains with gentle rolling hills
                    return 11 + Math.floor(3 * (
                        0.8 * simplex.noise2D(x * 0.01, z * 0.01) +
                        0.2 * simplex.noise2D(x * 0.04, z * 0.04)
                    ));
                    
                case 'forest':
                default:
                    return 12 + Math.floor(8 * (
                        0.6 * simplex.noise2D(x * 0.01, z * 0.01) +
                        0.4 * simplex.noise2D(x * 0.05, z * 0.05)
                    ));
            }
        }
        
        // Function to create a block with improved visual depth cues
        function createBlock(x, y, z, type, parent) {
            // Create the main block
            const material = blockMaterials[type] || blockMaterials.stone;
            
            // Create the block mesh without adding any edges or outlines
            const mesh = new THREE.Mesh(blockGeometry, material);
            mesh.position.set(x, y, z);
            
            // Add the block to the parent
            parent.add(mesh);
            return mesh;
        }
        
        // Create a tree with better color differentiation
        function createTree(x, y, z, parent) {
            // Tree trunk
            const trunkHeight = Math.floor(4 + (Math.abs(x * z) % 3)); // Deterministic height
            for (let i = 0; i < trunkHeight; i++) {
                createBlock(x, y + i, z, 'wood', parent);
                const posKey = `${x},${y + i},${z}`;
                parent.blockPositions[posKey] = { type: 'wood' };
            }
            
            // Tree leaves (more natural shape)
            const leafRadius = 2;
            const leafHeight = 3;
            for (let ly = 0; ly <= leafHeight; ly++) {
                // Make a wider canopy near the middle, narrower at top
                const levelRadius = ly === 0 || ly === leafHeight ? 1 : leafRadius;
                
                for (let lx = -levelRadius; lx <= levelRadius; lx++) {
                    for (let lz = -levelRadius; lz <= levelRadius; lz++) {
                        // Skip corners to make it more rounded
                        if (Math.abs(lx) === leafRadius && Math.abs(lz) === leafRadius) {
                            continue;
                        }
                        
                        // Check if leaf should be placed (deterministic randomness)
                        const leafSeed = (x + lx) * 1000 + (z + lz) * 10 + ly;
                        if (seededRandom(leafSeed)() > 0.8 && Math.abs(lx) === leafRadius && Math.abs(lz) === leafRadius) {
                            continue;
                        }
                        
                        createBlock(x + lx, y + trunkHeight + ly - 1, z + lz, 'grass', parent);
                        const posKey = `${x + lx},${y + trunkHeight + ly - 1},${z + lz}`;
                        parent.blockPositions[posKey] = { type: 'grass' };
                    }
                }
            }
        }
        
        // Seeded random function for deterministic generation
        function seededRandom(seed) {
            return function() {
                const x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            };
        }
        
        // Generate a single terrain chunk with optimized and fixed performance
        function generateChunk(chunkX, chunkZ, priority = 0, fadeIn = true) {
            const chunkKey = `${chunkX},${chunkZ}`;
            
            // If chunk already exists in the scene, don't regenerate
            if (terrain[chunkKey]) {
                console.log(`Chunk ${chunkKey} already exists in terrain, skipping generation`);
                return null;
            }
            
            // Check if we have the chunk in our cache
            if (chunkCache[chunkKey]) {
                console.log(`Restoring cached chunk: ${chunkKey}`);
                
                // Take the chunk from cache and add it back to the scene
                const chunkGroup = chunkCache[chunkKey];
                delete chunkCache[chunkKey]; // Remove from cache to avoid duplication
                
                // Setup fade in if needed
                if (fadeIn) {
                    chunkGroup.visible = true;
                    chunkGroup.userData = {
                        fadeState: 'in',
                        fadeProgress: 0,
                        fadeSpeed: 0.05,
                        fullyLoaded: false,
                        chunkX: chunkX,
                        chunkZ: chunkZ,
                        lastAccessed: Date.now()
                    };
                    
                    // Set all materials to be transparent for fading
                    chunkGroup.traverse(object => {
                        if (object.material) {
                            object.material.transparent = true;
                            if (typeof object.material.opacity === 'undefined') {
                                object.material._originalOpacity = 1;
                            }
                            object.material.opacity = 0;
                            object.material.needsUpdate = true;
                        }
                    });
                } else {
                    chunkGroup.userData = {
                        fadeState: 'visible',
                        fadeProgress: 1,
                        fullyLoaded: true,
                        chunkX: chunkX,
                        chunkZ: chunkZ,
                        lastAccessed: Date.now()
                    };
                }
                
                // Add the chunk to the scene
                scene.add(chunkGroup);
                terrain[chunkKey] = chunkGroup;
                
                // Check if this chunk has any player modifications
                if (chunkModifications[chunkKey]) {
                    applyChunkModifications(chunkKey, chunkGroup);
                }
                
                return chunkGroup;
            }
            
            console.log(`Generating new chunk: ${chunkKey}`);
            
            // Create a new chunk group
            const chunkGroup = new THREE.Group();
            chunkGroup.blockPositions = {};
            
            // If fadeIn is enabled, start with opacity 0
            if (fadeIn) {
                chunkGroup.visible = true;
                chunkGroup.userData = {
                    fadeState: 'in',
                    fadeProgress: 0,
                    fadeSpeed: 0.05, // Adjust for faster/slower fade
                    fullyLoaded: false,
                    chunkX: chunkX,
                    chunkZ: chunkZ,
                    lastAccessed: Date.now()
                };
            } else {
                chunkGroup.userData = {
                    fadeState: 'visible',
                    fadeProgress: 1,
                    fullyLoaded: true,
                    chunkX: chunkX,
                    chunkZ: chunkZ,
                    lastAccessed: Date.now()
                };
            }
            
            // Distance from player for LOD
            const playerChunkX = Math.floor(player.position.x / chunkSize);
            const playerChunkZ = Math.floor(player.position.z / chunkSize);
            const distanceFromPlayer = Math.max(Math.abs(chunkX - playerChunkX), Math.abs(chunkZ - playerChunkZ));
            
            // For optimized rendering, batch blocks by material
            const blocksByMaterial = {};
            
            // Function to add a block to the batch
            function addToBatch(worldX, y, worldZ, blockType) {
                if (!blocksByMaterial[blockType]) {
                    blocksByMaterial[blockType] = [];
                }
                blocksByMaterial[blockType].push({ x: worldX, y, z: worldZ });
                
                // Store position for collision detection
                const posKey = `${worldX},${y},${worldZ}`;
                chunkGroup.blockPositions[posKey] = { type: blockType };
            }
            
            // Check if this chunk has any player modifications before generating
            let hasModifications = false;
            if (chunkModifications[chunkKey]) {
                hasModifications = true;
            }
            
            // Generate blocks in chunk based on deterministic noise
            for (let x = 0; x < chunkSize; x++) {
                for (let z = 0; z < chunkSize; z++) {
                    const worldX = chunkX * chunkSize + x;
                    const worldZ = chunkZ * chunkSize + z;
                    
                    // Get terrain height - this needs to be consistent regardless of player position
                    const height = getTerrainHeight(worldX, worldZ, currentBiome);
                    
                    // Determine how deep to render based on distance (LOD)
                    // More aggressive depth reduction for better performance
                    const renderDepth = distanceFromPlayer === 0 ? 8 : 
                                       (distanceFromPlayer === 1 ? 4 : 2);
                    
                    // Generate blocks from surface to calculated depth
                    for (let y = height - 1; y > height - renderDepth && y >= 0; y--) {
                        // Check if this position has been modified by the player
                        const worldPosKey = `${worldX},${y},${worldZ}`;
                        if (hasModifications && chunkModifications[chunkKey][worldPosKey]) {
                            const modification = chunkModifications[chunkKey][worldPosKey];
                            if (modification.action === 'add') {
                                addToBatch(worldX, y, worldZ, modification.blockType);
                            }
                            // For 'remove' action, we simply don't add the block
                            continue;
                        }
                        
                        // Determine block type based on height and biome with more natural distribution
                        let blockType;
                        
                        if (y === height - 1) {
                            // Surface block - more realistic based on biome and elevation
                            switch (currentBiome) {
                                case 'desert':
                                    // Determine sand type based on noise patterns
                                    const sandNoise = simplex.noise2D(worldX * 0.05, worldZ * 0.05);
                                    const elevationFactor = simplex.noise2D(worldX * 0.01, worldZ * 0.01);
                                    
                                    // Create different sand types based on elevation and patterns
                                    if (sandNoise > 0.6) {
                                        blockType = 'sand_light'; // Light sand on dune tops
                                    } else if (sandNoise < -0.6) {
                                        blockType = 'sand_dark'; // Darker sand in lower areas
                                    } else if (elevationFactor > 0.4 && height > 10) {
                                        blockType = 'sand_red'; // Reddish sand on higher areas
                                    } else if (elevationFactor < -0.4) {
                                        blockType = 'sand_gold'; // Golden sand in specific patterns
                                    } else {
                                        blockType = 'sand'; // Base sand elsewhere
                                    }
                                    break;
                                case 'mountains':
                                    // Snow caps on mountain peaks, stone on cliffs, dirt/grass on lower areas
                                    if (y > 55) {
                                        blockType = 'snow'; // Snow-capped peaks
                                    } else if (y > 45) {
                                        // Transition zone - mix of snow and stone
                                        const snowThreshold = (y - 45) / 10; // 0 at y=45, 1 at y=55
                                        blockType = (Math.random() < snowThreshold) ? 'snow' : 'stone';
                                    } else if (y > 35) {
                                        blockType = 'stone'; // Rocky mountain sides
                                    } else if (y > 28) {
                                        // Transition zone - mix of stone and dirt
                                        const stoneThreshold = (y - 28) / 7; // 0 at y=28, 1 at y=35
                                        blockType = (Math.random() < stoneThreshold) ? 'stone' : 'dirt';
                                    } else {
                                        blockType = (y > 25) ? 'dirt' : 'grass'; // Lower slopes and valleys
                                    }
                                    break;
                                case 'plains':
                                    // Check for river or pond
                                    const riverNoise = Math.abs(simplex.noise2D(worldX * 0.02, worldZ * 0.02));
                                    if (riverNoise < 0.05 && y <= 8) {
                                        blockType = 'water'; // River water
                                    } else if (y === 8 && riverNoise < 0.05) {
                                        blockType = 'sand'; // River bed
                                    } else if (riverNoise < 0.12 && y < 11) {
                                        blockType = 'dirt'; // Riverbank
                                    } else {
                                        // Normal grass plains with some variety
                                        const varietyNoise = simplex.noise2D(worldX * 0.1, worldZ * 0.1);
                                        if (varietyNoise > 0.7) {
                                            blockType = 'dirt'; // Occasional dirt patches
                                        } else {
                                            blockType = 'grass'; // Mostly grass
                                        }
                                    }
                                    break;
                                case 'forest':
                                    blockType = 'grass';
                                    // Add occasional dirt patches
                                    if (Math.random() < 0.05) blockType = 'dirt';
                                    break;
                            }
                        } else if (y > height - 4) {
                            // Subsurface layers
                            if (currentBiome === 'desert') {
                                // Add some variation to subsurface sand too
                                blockType = 'sand';
                            } else if (currentBiome === 'mountains') {
                                if (y > 50) {
                                    blockType = 'snow'; // Snow layers under surface
                                } else if (y > 35) {
                                    blockType = 'stone'; // Stone layers in mountains
                                } else {
                                    blockType = 'dirt'; // Dirt layers at lower elevations
                                }
                            } else if (currentBiome === 'plains' && y <= 8) {
                                // River bottom is sandy
                                const riverNoise = Math.abs(simplex.noise2D(worldX * 0.02, worldZ * 0.02));
                                if (riverNoise < 0.05) {
                                    blockType = 'sand';
                                } else {
                                    blockType = 'dirt';
                                }
                            } else {
                                blockType = 'dirt';
                            }
                        } else {
                            // Deep layers
                            blockType = 'stone';
                        }
                        
                        // Add to the appropriate material batch instead of creating individual blocks
                        addToBatch(worldX, y, worldZ, blockType);
                    }
                    
                    // Add biome-specific features with deterministic placement only in close chunks
                    if (distanceFromPlayer <= 1) {
                        // Use a deterministic seed for features so they don't change when we regenerate chunks
                        const featureSeed = worldX * 10000 + worldZ;
                        const featureRandom = seededRandom(featureSeed);
                        
                        // FOREST FEATURES
                        if (currentBiome === 'forest' && featureRandom() < 0.03 && height > 5) {
                            createTree(worldX, height, worldZ, chunkGroup);
                        }
                        
                        // DESERT FEATURES - simplify to reduce object count
                        if (currentBiome === 'desert') {
                            const dunePattern = simplex.noise2D(worldX * 0.03, worldZ * 0.03);
                            if (dunePattern > 0.7 && height > 9) {
                                // Add single dune crest blocks instead of complex structures
                                addToBatch(worldX, height, worldZ, 'sand_light');
                            }
                        }
                        
                        // MOUNTAIN FEATURES - simplify
                        if (currentBiome === 'mountains' && featureRandom() < 0.02 && height < 50 && height > 30) {
                            // Just add some stone variation rather than complex structures
                            addToBatch(worldX, height, worldZ, 'stone');
                        }
                        
                        // PLAINS FEATURES - simplify
                        if (currentBiome === 'plains') {
                            const riverNoise = Math.abs(simplex.noise2D(worldX * 0.02, worldZ * 0.02));
                            if (riverNoise >= 0.12 && featureRandom() < 0.001 && height > 10) {
                                createTree(worldX, height, worldZ, chunkGroup);
                            }
                        }
                    }
                }
            }
            
            // Now create instanced meshes for each material type
            for (const [blockType, positions] of Object.entries(blocksByMaterial)) {
                if (positions.length === 0) continue;
                
                // Skip if we don't have a valid material for this block type
                if (!blockMaterials[blockType]) {
                    console.warn(`Missing material for block type: ${blockType}`);
                    continue;
                }
                
                // Get the material for this block type
                const material = blockMaterials[blockType];
                
                // Create a copy of the material that can be modified for the fade effect
                const fadeMaterial = material.clone();
                
                // If we're fading in, start with transparent material
                if (fadeIn) {
                    fadeMaterial.transparent = true;
                    fadeMaterial.opacity = 0;
                }
                
                try {
                    // If there are lots of blocks, use instancing for better performance
                    if (positions.length > 10) {
                        const instancedMesh = new THREE.InstancedMesh(
                            blockGeometry,
                            fadeMaterial,
                            positions.length
                        );
                        
                        // Set matrix for each instance
                        const matrix = new THREE.Matrix4();
                        for (let i = 0; i < positions.length; i++) {
                            const pos = positions[i];
                            matrix.setPosition(pos.x, pos.y, pos.z);
                            instancedMesh.setMatrixAt(i, matrix);
                        }
                        
                        // Update the instance buffer
                        instancedMesh.instanceMatrix.needsUpdate = true;
                        chunkGroup.add(instancedMesh);
                    } 
                    // For a small number of blocks, regular meshes are fine
                    else {
                        positions.forEach(pos => {
                            const mesh = new THREE.Mesh(blockGeometry, fadeMaterial);
                            mesh.position.set(pos.x, pos.y, pos.z);
                            chunkGroup.add(mesh);
                        });
                    }
                } catch (error) {
                    console.error(`Error creating mesh for block type ${blockType}:`, error);
                }
            }
            
            // Add the chunk to the scene
            scene.add(chunkGroup);
            terrain[chunkKey] = chunkGroup;
            
            // Mark the chunk as fully loaded when generation is complete
            if (!fadeIn) {
                chunkGroup.userData.fullyLoaded = true;
            }
            
            // Apply any modifications if they exist
            if (hasModifications) {
                applyChunkModifications(chunkKey, chunkGroup);
            }
            
            return chunkGroup;
        }
        
        // Create a tall grass decoration
        function createTallGrass(x, y, z, parent) {
            // Create a cross-shaped tall grass using two rotated planes
            const grassBlock = new THREE.Group();
            grassBlock.position.set(x, y, z);
            
            // Use a slightly different green than regular grass blocks
            const grassMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x5DB653, 
                transparent: true,
                opacity: 0.9
            });
            
            // Create a simple box for now - could be enhanced with actual grass models
            const grass = new THREE.Mesh(blockGeometry, grassMaterial);
            grass.scale.set(0.5, 0.5, 0.5);
            grass.position.y += 0.3;
            
            grassBlock.add(grass);
            parent.add(grassBlock);
            
            // Add to block positions for collision
            const posKey = `${x},${y},${z}`;
            parent.blockPositions[posKey] = { type: 'tallgrass', collision: false };
            
            return grassBlock;
        }
        
        // Create a flower
        function createFlower(x, y, z, flowerType, parent) {
            const flowerBlock = new THREE.Group();
            flowerBlock.position.set(x, y, z);
            
            // Different materials for different flower types
            let flowerMaterial;
            if (flowerType === 'red_flower') {
                flowerMaterial = new THREE.MeshLambertMaterial({ color: 0xE05858 });
            } else {
                flowerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFF156 });
            }
            
            // Create a simple small cube for the flower
            const flower = new THREE.Mesh(blockGeometry, flowerMaterial);
            flower.scale.set(0.4, 0.4, 0.4);
            flower.position.y += 0.3;
            
            flowerBlock.add(flower);
            parent.add(flowerBlock);
            
            // Flowers don't block movement
            const posKey = `${x},${y},${z}`;
            parent.blockPositions[posKey] = { type: flowerType, collision: false };
            
            return flowerBlock;
        }
        
        // Create a water lily pad
        function createWaterLily(x, y, z, parent) {
            const lilyGroup = new THREE.Group();
            lilyGroup.position.set(x, y, z);
            
            // Create lily pad with green material
            const lilyMaterial = new THREE.MeshLambertMaterial({ color: 0x2D8653 });
            const lily = new THREE.Mesh(blockGeometry, lilyMaterial);
            lily.scale.set(0.8, 0.1, 0.8);
            
            lilyGroup.add(lily);
            parent.add(lilyGroup);
            
            // Lily pads don't have collision
            const posKey = `${x},${y},${z}`;
            parent.blockPositions[posKey] = { type: 'lily_pad', collision: false };
            
            return lilyGroup;
        }
        
        // Create reed (cattail)
        function createReed(x, y, z, parent) {
            const reedGroup = new THREE.Group();
            reedGroup.position.set(x, y, z);
            
            // Create reed stem and top
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x76A83B });
            const topMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            
            // Stem
            const stem = new THREE.Mesh(blockGeometry, stemMaterial);
            stem.scale.set(0.2, 0.8, 0.2);
            
            // Top
            const top = new THREE.Mesh(blockGeometry, topMaterial);
            top.scale.set(0.3, 0.3, 0.3);
            top.position.y += 0.6;
            
            reedGroup.add(stem);
            reedGroup.add(top);
            parent.add(reedGroup);
            
            // Reeds don't have collision
            const posKey = `${x},${y},${z}`;
            parent.blockPositions[posKey] = { type: 'reed', collision: false };
            
            return reedGroup;
        }
        
        // Create a small pond
        function createPond(x, y, z, parent) {
            // Create a small circular pond
            const pondRadius = 2 + Math.floor(seededRandom(x * z)() * 3);
            
            for (let dx = -pondRadius; dx <= pondRadius; dx++) {
                for (let dz = -pondRadius; dz <= pondRadius; dz++) {
                    const distance = Math.sqrt(dx*dx + dz*dz);
                    if (distance <= pondRadius) {
                        // Create water block
                        createBlock(x + dx, y - 1, z + dz, 'water', parent);
                        const waterKey = `${x + dx},${y - 1},${z + dz}`;
                        parent.blockPositions[waterKey] = { type: 'water' };
                        
                        // Create sand around edge of pond
                        if (distance > pondRadius - 1) {
                            for (let dy = -2; dy < 0; dy++) {
                                createBlock(x + dx, y + dy, z + dz, 'sand', parent);
                                const sandKey = `${x + dx},${y + dy},${z + dz}`;
                                parent.blockPositions[sandKey] = { type: 'sand' };
                            }
                        }
                        
                        // Add lily pads occasionally
                        if (distance < pondRadius - 0.5 && seededRandom(x + dx * 100 + z + dz)() < 0.1) {
                            createWaterLily(x + dx, y, z + dz, parent);
                        }
                    }
                }
            }
        }
        
        // Function to generate terrain with optimization and caching
        function generateTerrain() {
            console.log("Generating terrain with biome:", currentBiome);
            
            // Clear terrain if switching biomes or initial spawn
            if (player.isSpawning) {
                // When spawning, we actually need to clear everything
                Object.keys(terrain).forEach(chunkKey => {
                    disposeChunk(terrain[chunkKey]);
                    scene.remove(terrain[chunkKey]);
                    delete terrain[chunkKey];
                });
                terrain = {};
                chunkCache = {}; // Also clear the cache
                chunkModifications = {}; // Clear modifications
                chunkLoadingQueue = []; // Clear the loading queue
            }
            
            // Get player chunk position
            const playerChunkX = Math.floor(player.position.x / chunkSize);
            const playerChunkZ = Math.floor(player.position.z / chunkSize);
            
            // Update player direction for predictive loading
            updatePlayerDirection();
            
            // Track which chunks should remain active
            const activeChunks = new Set();
            
            // Clear the loading queue to avoid stale chunks
            chunkLoadingQueue = [];
            
            // Calculate the forward direction for chunk preloading
            let lookAheadX = Math.round(playerDirection.x * 2);
            let lookAheadZ = Math.round(playerDirection.z * 2);
            
            // If we don't have a clear direction, default to player's orientation
            if (Math.abs(lookAheadX) < 0.5 && Math.abs(lookAheadZ) < 0.5) {
                // Use camera direction instead
                const cameraDirection = controls.getDirection(new THREE.Vector3());
                cameraDirection.y = 0;
                cameraDirection.normalize();
                cameraDirection.multiplyScalar(2);
                lookAheadX = Math.round(cameraDirection.x);
                lookAheadZ = Math.round(cameraDirection.z);
            }
            
            // For debugging
            console.log(`Player at chunk (${playerChunkX}, ${playerChunkZ}), looking toward (${lookAheadX}, ${lookAheadZ})`);
            
            // Generate chunks in multiple passes with different priorities
            
            // Pass 1: Immediate visibility chunks (highest priority)
            for (let x = -chunkRenderDistance.minimum; x <= chunkRenderDistance.minimum; x++) {
                for (let z = -chunkRenderDistance.minimum; z <= chunkRenderDistance.minimum; z++) {
                    const chunkX = playerChunkX + x;
                    const chunkZ = playerChunkZ + z;
                    const chunkKey = `${chunkX},${chunkZ}`;
                    
                    activeChunks.add(chunkKey);
                    
                    // Generate immediately and with no fade for close chunks
                    if (!terrain[chunkKey]) {
                        console.log(`Immediate generation of chunk ${chunkKey}`);
                        const newChunk = generateChunk(chunkX, chunkZ, 3, false);
                        if (newChunk) {
                            console.log(`Successfully generated chunk ${chunkKey}`);
                        } else {
                            console.log(`Failed to generate chunk ${chunkKey}`);
                        }
                    } else {
                        // Update last accessed time for this chunk
                        if (terrain[chunkKey].userData) {
                            terrain[chunkKey].userData.lastAccessed = Date.now();
                        }
                    }
                }
            }
            
            // Pass 2: Standard visibility range (high priority)
            for (let x = -chunkRenderDistance.ideal; x <= chunkRenderDistance.ideal; x++) {
                for (let z = -chunkRenderDistance.ideal; z <= chunkRenderDistance.ideal; z++) {
                    // Skip chunks already processed in pass 1
                    if (Math.abs(x) <= chunkRenderDistance.minimum && Math.abs(z) <= chunkRenderDistance.minimum) 
                        continue;
                    
                    const chunkX = playerChunkX + x;
                    const chunkZ = playerChunkZ + z;
                    const chunkKey = `${chunkX},${chunkZ}`;
                    
                    activeChunks.add(chunkKey);
                    
                    if (terrain[chunkKey]) {
                        // Update last accessed time for this chunk
                        if (terrain[chunkKey].userData) {
                            terrain[chunkKey].userData.lastAccessed = Date.now();
                        }
                    } else {
                        // Add to loading queue with high priority
                        console.log(`Queueing chunk ${chunkKey} with high priority`);
                        chunkLoadingQueue.push({
                            x: chunkX,
                            z: chunkZ,
                            priority: 2,
                            fadeIn: true
                        });
                    }
                }
            }
            
            // Pass 3: Extended visibility (medium priority)
            for (let x = -chunkRenderDistance.maximum; x <= chunkRenderDistance.maximum; x++) {
                for (let z = -chunkRenderDistance.maximum; z <= chunkRenderDistance.maximum; z++) {
                    // Skip chunks already processed in earlier passes
                    if (Math.abs(x) <= chunkRenderDistance.ideal && Math.abs(z) <= chunkRenderDistance.ideal) 
                        continue;
                    
                    const chunkX = playerChunkX + x;
                    const chunkZ = playerChunkZ + z;
                    const chunkKey = `${chunkX},${chunkZ}`;
                    
                    activeChunks.add(chunkKey);
                    
                    if (terrain[chunkKey]) {
                        // Update last accessed time for this chunk
                        if (terrain[chunkKey].userData) {
                            terrain[chunkKey].userData.lastAccessed = Date.now();
                        }
                    } else {
                        // Add to loading queue with medium priority
                        chunkLoadingQueue.push({
                            x: chunkX,
                            z: chunkZ,
                            priority: 1,
                            fadeIn: true
                        });
                    }
                }
            }
            
            // Pass 4: Look-ahead chunks in player movement direction (low priority)
            if (lookAheadX !== 0 || lookAheadZ !== 0) {
                const lookDistance = chunkRenderDistance.preloadFar;
                
                for (let dist = chunkRenderDistance.maximum + 1; dist <= lookDistance; dist++) {
                    // Generate chunks ahead in player's movement direction
                    for (let spread = -1; spread <= 1; spread++) {
                        // Calculate positions along movement vector
                        let preloadX, preloadZ;
                        
                        if (Math.abs(lookAheadX) > Math.abs(lookAheadZ)) {
                            // Moving primarily along X axis
                            preloadX = playerChunkX + (lookAheadX > 0 ? dist : -dist);
                            preloadZ = playerChunkZ + spread;
                        } else {
                            // Moving primarily along Z axis
                            preloadX = playerChunkX + spread;
                            preloadZ = playerChunkZ + (lookAheadZ > 0 ? dist : -dist);
                        }
                        
                        const chunkKey = `${preloadX},${preloadZ}`;
                        activeChunks.add(chunkKey);
                        
                        if (terrain[chunkKey]) {
                            // Update last accessed time for this chunk
                            if (terrain[chunkKey].userData) {
                                terrain[chunkKey].userData.lastAccessed = Date.now();
                            }
                        } else {
                            // Add to loading queue with low priority
                            chunkLoadingQueue.push({
                                x: preloadX,
                                z: preloadZ,
                                priority: 0,
                                fadeIn: true
                            });
                        }
                    }
                }
            }
            
            // Log active chunks for debugging
            console.log(`Active chunks: ${activeChunks.size}`);
            
            // Manage chunk hibernation (move to cache instead of disposal)
            Object.keys(terrain).forEach(chunkKey => {
                if (!activeChunks.has(chunkKey)) {
                    const chunk = terrain[chunkKey];
                    
                    // Don't fade chunks that aren't fully loaded yet
                    if (!chunk.userData || !chunk.userData.fullyLoaded) {
                        console.log(`Immediately disposing not-fully-loaded chunk: ${chunkKey}`);
                        disposeChunk(chunk);
                        scene.remove(chunk);
                        delete terrain[chunkKey];
                    } 
                    // Start fade out for chunks that should be cached
                    else if (chunk.userData.fadeState !== 'out') {
                        console.log(`Starting fade-out for chunk: ${chunkKey}`);
                        chunk.userData.fadeState = 'out';
                        chunk.userData.fadeProgress = 1;
                        chunk.userData.targetCache = true; // Mark for caching instead of removal
                        
                        // Make sure material is set up for fading
                        chunk.traverse(object => {
                            if (object.material) {
                                object.material.transparent = true;
                                // Store original opacity if needed
                                if (typeof object.material.opacity === 'undefined' || 
                                    !object.material.hasOwnProperty('_originalOpacity')) {
                                    object.material._originalOpacity = object.material.opacity;
                                }
                                object.material.needsUpdate = true;
                            }
                        });
                    }
                }
            });
            
            // Debug info
            console.log(`Currently ${Object.keys(terrain).length} active chunks, ${chunkLoadingQueue.length} in queue, ${Object.keys(chunkCache).length} in cache`);
            
            // Start processing the chunk queue
            processChunkQueue();
            
            // If cache is getting too large, prune the oldest chunks
            pruneChunkCache();
            
            // If this is initial spawn, check for a safe position
            if (player.isSpawning) {
                // Wait a frame to allow terrain to generate
                setTimeout(() => {
                    // Find a safe position on the ground
                    const groundY = findGroundLevel(player.position.x, player.position.z);
                    if (groundY !== -1) {
                        player.position.y = groundY + 2; // Position 2 blocks above ground
                        camera.position.copy(player.position);
                        camera.position.y += 1.7; // Eye height
                        player.spawned = true;
                    }
                    player.isSpawning = false;
                    console.log("Player spawned at:", player.position);
                }, 100);
            }
        }
        
        // Function to remove old chunks from cache when it gets too large
        function pruneChunkCache() {
            const cacheSize = Object.keys(chunkCache).length;
            if (cacheSize <= maxCachedChunks) return;
            
            console.log(`Pruning chunk cache. Current size: ${cacheSize}`);
            
            // Convert cache to array for sorting
            const chunks = Object.entries(chunkCache).map(([key, chunk]) => {
                return {
                    key: key,
                    chunk: chunk,
                    lastAccessed: chunk.userData ? chunk.userData.lastAccessed || 0 : 0
                };
            });
            
            // Sort by last accessed time (oldest first)
            chunks.sort((a, b) => a.lastAccessed - b.lastAccessed);
            
            // Remove oldest chunks until we're back under the limit
            const toRemove = cacheSize - maxCachedChunks;
            for (let i = 0; i < toRemove; i++) {
                const chunk = chunks[i];
                console.log(`Removing old chunk from cache: ${chunk.key}, last accessed: ${new Date(chunk.lastAccessed).toLocaleTimeString()}`);
                disposeChunk(chunk.chunk);
                delete chunkCache[chunk.key];
            }
            
            console.log(`Cache pruned. New size: ${Object.keys(chunkCache).length}`);
        }

        // Update all chunk fade transitions with caching
        function updateChunkFades(delta) {
            Object.values(terrain).forEach(chunk => {
                if (!chunk.userData) return;
                
                // Handle fade in
                if (chunk.userData.fadeState === 'in' && chunk.userData.fadeProgress < 1) {
                    chunk.userData.fadeProgress += chunk.userData.fadeSpeed;
                    
                    if (chunk.userData.fadeProgress >= 1) {
                        chunk.userData.fadeProgress = 1;
                        chunk.userData.fadeState = 'visible';
                        chunk.userData.fullyLoaded = true;
                        
                        // Fix materials after fade completes
                        chunk.traverse(object => {
                            if (object.material && object.material.transparent) {
                                object.material.opacity = 1;
                                
                                // Only turn off transparency if the material should be fully opaque
                                if (object.material.type !== 'MeshLambertMaterial' || 
                                    !object.material._originalOpacity || 
                                    object.material._originalOpacity >= 1) {
                                    object.material.transparent = false;
                                    object.material.needsUpdate = true;
                                }
                            }
                        });
                    } else {
                        // Update opacity during fade
                        const opacity = chunk.userData.fadeProgress;
                        chunk.traverse(object => {
                            if (object.material) {
                                if (!object.material.transparent) {
                                    object.material.transparent = true;
                                    // Store original opacity if it exists
                                    if (typeof object.material.opacity !== 'undefined') {
                                        object.material._originalOpacity = object.material.opacity;
                                    }
                                }
                                object.material.opacity = opacity * (object.material._originalOpacity || 1);
                                object.material.needsUpdate = true;
                            }
                        });
                    }
                }
                
                // Handle fade out
                else if (chunk.userData.fadeState === 'out' && chunk.userData.fadeProgress > 0) {
                    chunk.userData.fadeProgress -= chunk.userData.fadeSpeed * 2; // Faster fade out
                    
                    if (chunk.userData.fadeProgress <= 0) {
                        chunk.userData.fadeProgress = 0;
                        
                        // Find chunk key
                        let chunkKey = null;
                        for (const key in terrain) {
                            if (terrain[key] === chunk) {
                                chunkKey = key;
                                break;
                            }
                        }
                        
                        // If the chunk is marked for caching and we have a valid key, move it to cache
                        if (chunk.userData.targetCache && chunkKey) {
                            console.log(`Moving chunk to cache: ${chunkKey}`);
                            // Store in cache instead of disposing
                            scene.remove(chunk);
                            chunkCache[chunkKey] = chunk;
                            delete terrain[chunkKey];
                        } else {
                            console.log(`Disposing chunk: ${chunkKey || 'unknown'}`);
                            // Remove the chunk completely
                            disposeChunk(chunk);
                            scene.remove(chunk);
                            
                            // Find and remove from terrain object
                            if (chunkKey) {
                                delete terrain[chunkKey];
                            }
                        }
                    } else {
                        // Update opacity during fade
                        const opacity = chunk.userData.fadeProgress;
                        chunk.traverse(object => {
                            if (object.material) {
                                if (!object.material.transparent) {
                                    object.material.transparent = true;
                                }
                                object.material.opacity = opacity * (object.material._originalOpacity || 1);
                                object.material.needsUpdate = true;
                            }
                        });
                    }
                }
            });
        }
        
        // Set up scene lighting with improved balance
        function setupLights() {
            // Main directional light (sun/moon) with warmer color
            const directionalLight = new THREE.DirectionalLight(0xFFEAC3, 1.2); // Slightly increased intensity
            directionalLight.position.set(100, 100, 50);
            
            // Add shadows for better depth perception
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            scene.add(directionalLight);
            
            // Add a secondary directional light from a different angle
            const secondaryLight = new THREE.DirectionalLight(0xCCDDFF, 0.4); // Cooler light
            secondaryLight.position.set(-50, 80, -50);
            scene.add(secondaryLight);
            
            // Ambient light - improved for color fidelity
            const ambientLight = new THREE.AmbientLight(0x8097BB, 0.5);
            scene.add(ambientLight);
            
            // Store lights for day/night cycle
            dayNightCycle.directionalLight = directionalLight;
            dayNightCycle.secondaryLight = secondaryLight;
            dayNightCycle.ambientLight = ambientLight;
        }
        function setupOptimizedLights() {
            // Optimized directional light setup
            const directionalLight = new THREE.DirectionalLight(0xFFEAC3, 1.2);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;  
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            scene.add(directionalLight);
            
            // Optimized ambient light setup
            const ambientLight = new THREE.AmbientLight(0x8097BB, 0.5);
            scene.add(ambientLight);

            // Store lights for day/night cycle
            dayNightCycle.directionalLight = directionalLight;
            dayNightCycle.ambientLight = ambientLight;
        }
        
        // Optimized lighting update function
        function updateOptimizedLights() {
            // Update directional light position based on time of day
            const timeOfDay = dayNightCycle.timeOfDay;
            const angle = timeOfDay * Math.PI * 2;
            dayNightCycle.directionalLight.position.set(
                Math.sin(angle) * 100,
                100,
                Math.cos(angle) * 100
            );
        }
        
        
        
        // Handle toggle between game and UI modes
        function toggleUIMode() {
            if (controls.isLocked) {
                controls.unlock();
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('uiModeMessage').style.display = 'block';
            } else {
                controls.lock();
                document.getElementById('uiModeMessage').style.display = 'none';
            }
        }
        
        // Play ambient sound based on biome
        function playAmbientSound(biome) {
            // Pause all ambient sounds first
            Object.values(ambientSounds).forEach(sound => sound.pause());
            
            // Play the selected biome sound on loop
            if (ambientSounds[biome]) {
                ambientSounds[biome].loop = true;
                ambientSounds[biome].volume = 0.3;
                ambientSounds[biome].play().catch(error => console.log("Audio playback error:", error));
            }
        }
        
        // Setup UI interaction
        function setupUI() {
            // Block selection
            document.querySelectorAll('.block-type').forEach(element => {
                element.addEventListener('click', () => {
                    // Remove selected class from all blocks
                    document.querySelectorAll('.block-type').forEach(el => {
                        el.classList.remove('selected');
                    });
                    
                    // Add selected class to clicked block
                    element.classList.add('selected');
                    
                    // Update selected block type
                    selectedBlockType = element.dataset.type;
                });
            });
            
            // Biome selection with proper spawn handling
            document.querySelectorAll('.biome-btn').forEach(element => {
                element.addEventListener('click', () => {
                    console.log("Biome button clicked:", element.dataset.biome);
                    
                    // Remove active class from all biome buttons
                    document.querySelectorAll('.biome-btn').forEach(el => {
                        el.classList.remove('active');
                    });
                    
                    // Add active class to clicked button
                    element.classList.add('active');
                    
                    // Update current biome
                    currentBiome = element.dataset.biome;
                    
                    // Reset player for safe spawning in new biome
                    player.isSpawning = true;
                    
                    // Find a safe spawn location in the new biome
                    findSafeSpawnPoint();
                    
                    // Force regeneration of terrain with new biome
                    Object.keys(terrain).forEach(chunkKey => {
                        scene.remove(terrain[chunkKey]);
                        delete terrain[chunkKey];
                    });
                    terrain = {};
                    generateTerrain();
                    
                    // Update ambient sound
                    if (isGameStarted) {
                        playAmbientSound(currentBiome);
                    }
                    
                    console.log("Changed biome to:", currentBiome);
                });
            });
            
            // Add respawn button
            const respawnButton = document.createElement('button');
            respawnButton.textContent = 'Respawn';
            respawnButton.style.position = 'absolute';
            respawnButton.style.bottom = '10px';
            respawnButton.style.right = '10px';
            respawnButton.style.padding = '8px 12px';
            respawnButton.style.background = '#4CAF50';
            respawnButton.style.color = 'white';
            respawnButton.style.border = 'none';
            respawnButton.style.borderRadius = '4px';
            respawnButton.style.cursor = 'pointer';
            respawnButton.style.zIndex = '1000';
            
            respawnButton.addEventListener('click', () => {
                player.isSpawning = true;
                findSafeSpawnPoint();
                player.velocity.set(0, 0, 0);
                generateTerrain();
            });
            
            document.body.appendChild(respawnButton);
            
            // Prevent context menu on right-click
            document.addEventListener('contextmenu', event => event.preventDefault());
            
            // Add crafting instructions
            const craftingTip = document.createElement('p');
            craftingTip.textContent = 'Press E to open crafting menu';
            document.getElementById('instructions').insertBefore(
                craftingTip, 
                document.getElementById('startButton')
            );
        }
        
        // Add this function to ensure all buttons have proper data-biome attributes
        function checkBiomeButtons() {
            const biomeButtons = document.querySelectorAll('.biome-btn');
            console.log("Biome buttons found:", biomeButtons.length);
            
            biomeButtons.forEach(button => {
                console.log(`Button: ${button.textContent}, data-biome: ${button.dataset.biome}`);
                
                // If button doesn't have data-biome attribute, try to set it based on its text content
                if (!button.dataset.biome) {
                    const text = button.textContent.toLowerCase().trim();
                    if (text === 'forest' || text === 'desert' || text === 'mountains' || text === 'plains') {
                        button.dataset.biome = text;
                        console.log(`Fixed missing data-biome attribute on button: ${text}`);
                    }
                }
            });
        }
        
        // Initialize the game with optimized settings
        function init() {
            // Create Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 15, 45); // Closer fog for better performance and hide pop-in
            
            // First find a safe spawn point based on biome
            findSafeSpawnPoint();
            
            // Set up camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(player.position);
            
            // Create renderer with WebGL 2 if available
            renderer = new THREE.WebGLRenderer({
                antialias: false,
                alpha: false,
                preserveDrawingBuffer: false,
                powerPreference: 'high-performance'
            });
            
            // Set precision for better performance
            renderer.precision = 'mediump';
            
            // Enable performance optimizations
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            
            // Get WebGL context
            const gl = renderer.getContext();
            
            // Check for and enable WebGL extensions
            const extensions = {
                // Allow larger index buffers (>65536 indices)
                uint32Indices: gl.getExtension('OES_element_index_uint'),
                // Anisotropic filtering for better texture quality at angles
                anisotropic: gl.getExtension('EXT_texture_filter_anisotropic'),
                // Depth textures for better shadow mapping
                depthTexture: gl.getExtension('WEBGL_depth_texture'),
                // Compressed textures for memory usage optimization
                compressedTextures: gl.getExtension('WEBGL_compressed_texture_s3tc'),
                // Hardware instancing for better performance with many similar objects
                instancedArrays: gl.getExtension('ANGLE_instanced_arrays'),
                // Allow vertex shader texture access
                vertexTextures: gl.getExtension('OES_texture_float')
            };
            
            // Log available extensions
            console.log("WebGL Extensions:", extensions);
            
            // Store extensions for later use
            window.glExtensions = extensions;
            
            // Set up renderer with performance optimizations and shadows
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadow edges
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB, 1);
            document.body.appendChild(renderer.domElement);
            
            // Create UI mode message
            const uiModeMessage = document.createElement('div');
            uiModeMessage.id = 'uiModeMessage';
            uiModeMessage.style.position = 'absolute';
            uiModeMessage.style.top = '10px';
            uiModeMessage.style.left = '50%';
            uiModeMessage.style.transform = 'translateX(-50%)';
            uiModeMessage.style.background = 'rgba(0,0,0,0.7)';
            uiModeMessage.style.color = 'white';
            uiModeMessage.style.padding = '10px';
            uiModeMessage.style.borderRadius = '5px';
            uiModeMessage.style.zIndex = '1000';
            uiModeMessage.style.display = 'none';
            uiModeMessage.innerHTML = 'UI Mode Active - Click game to resume or press Tab';
            document.body.appendChild(uiModeMessage);
            
            // Set up controls
            controls = new THREE.PointerLockControls(camera, document.body);
            document.getElementById('startButton').addEventListener('click', () => {
                try {
                    controls.lock();
                    console.log("Controls locked");
                } catch (e) {
                    console.error("Error locking controls:", e);
                }
            });
            
            controls.addEventListener('lock', () => {
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('uiModeMessage').style.display = 'none';
                isGameStarted = true;
                
                // Start playing ambient sound based on biome
                try {
                    playAmbientSound(currentBiome);
                } catch (e) {
                    console.error("Error playing sound:", e);
                }
            });
            
            controls.addEventListener('unlock', () => {
                if (!isGameStarted) {
                    document.getElementById('instructions').style.display = 'flex';
                }
            });
            
            // Add Tab key to toggle UI mode
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && isGameStarted) {
                    controls.unlock();
                    document.getElementById('instructions').style.display = 'flex';
                    isGameStarted = false;
                    
                    // Pause all ambient sounds
                    try {
                        Object.values(ambientSounds).forEach(sound => sound.pause());
                    } catch (e) {
                        console.error("Error pausing sounds:", e);
                    }
                }
                
                if (event.key === 'Tab' && isGameStarted) {
                    event.preventDefault(); // Prevent tab from changing focus
                    toggleUIMode();
                }
                
                console.log("Key pressed:", event.key);
            });
            
            // Update instructions to include Tab key information
            const instructionsElement = document.getElementById('instructions');
            const tabTip = document.createElement('p');
            tabTip.textContent = 'Press TAB to toggle mouse cursor for UI interaction';
            instructionsElement.insertBefore(tabTip, document.getElementById('startButton'));
            
            console.log("Setting up lighting");
            // Add lights
            // need a optimized lighting system
            // setupOptimizedLights();
            // setupLights();
            setupHighlyOptimizedLights();
            
            console.log("Generating terrain");
            // Generate initial terrain
            generateTerrain();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseClick);
            
            // Setup UI interaction
            setupUI();
            
            // Check biome buttons
            setTimeout(checkBiomeButtons, 500); // Give DOM time to fully load
            
            // Start animation loop
            animate();
            console.log("Game initialized with biome:", currentBiome);
            
            // Initialize crafting system after DOM is loaded
            setTimeout(() => {
                initCraftingSystem();
                // Give player some starting resources
                playerInventory.wood = 5;
                updateInventoryDisplay();
            }, 1000);
            
            // Initialize the highlight box after scene is created
            initHighlightBox();
            
            createFpsCounter();
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle keyboard input
        function onKeyDown(event) {
            keyboard[event.key.toLowerCase()] = true;
            
            // Alternative movement keys for trackpad users
            if (event.key === 'ArrowUp') keyboard['w'] = true;
            if (event.key === 'ArrowDown') keyboard['s'] = true;
            if (event.key === 'ArrowLeft') keyboard['a'] = true;
            if (event.key === 'ArrowRight') keyboard['d'] = true;
        }
        
        function onKeyUp(event) {
            keyboard[event.key.toLowerCase()] = false;
            
            // Alternative movement keys for trackpad users
            if (event.key === 'ArrowUp') keyboard['w'] = false;
            if (event.key === 'ArrowDown') keyboard['s'] = false;
            if (event.key === 'ArrowLeft') keyboard['a'] = false;
            if (event.key === 'ArrowRight') keyboard['d'] = false;
        }
        
        // Handle mouse clicks for block manipulation
        function onMouseClick(event) {
            if (!isGameStarted) return;
            
            // Cast ray from camera
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            
            // Find all intersections with terrain chunks
            const intersections = [];
            Object.values(terrain).forEach(chunk => {
                // We need to check each block in the chunk
                for (const [posKey, blockData] of Object.entries(chunk.blockPositions)) {
                    const [x, y, z] = posKey.split(',').map(Number);
                    const blockBox = new THREE.Box3(
                        new THREE.Vector3(x - 0.5, y - 0.5, z - 0.5),
                        new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5)
                    );
                    
                    // Check for intersection with this block
                    const intersect = raycaster.ray.intersectBox(blockBox, new THREE.Vector3());
                    if (intersect) {
                        intersections.push({
                            distance: intersect.distanceTo(camera.position),
                            point: intersect.clone(),
                            normal: raycaster.ray.direction.clone().negate(),
                            blockPosition: { x, y, z },
                            chunk: chunk,
                            blockData: blockData
                        });
                    }
                }
            });
            
            // Sort by distance
            intersections.sort((a, b) => a.distance - b.distance);
            
            if (intersections.length > 0) {
                const intersection = intersections[0];
                
                if (event.button === 0) {
                    // Left click - remove block
                    removeBlock(intersection);
                } else if (event.button === 2) {
                    // Right click - place block
                    placeBlock(intersection);
                }
            }
        }
        
        // Remove a block
        function removeBlock(intersection) {
            const { chunk, blockPosition } = intersection;
            const posKey = `${blockPosition.x},${blockPosition.y},${blockPosition.z}`;
            
            // Get block type before deletion
            const blockData = chunk.blockPositions[posKey];
            if (blockData) {
                const blockType = blockData.type;
                
                // Map block type to inventory resource
                let resource = blockType;
                
                // Check for special types (for example, wooden_pickaxe stays as is)
                if (blockType === 'grass') resource = 'grass';
                else if (blockType === 'stone') resource = 'stone';
                else if (blockType === 'dirt') resource = 'dirt';
                else if (blockType === 'sand') resource = 'sand';
                else if (blockType === 'wood') resource = 'wood';
                else if (blockType.includes('sand_')) resource = 'sand'; // All sand variants give sand
                
                // Add to inventory
                playerInventory[resource] = (playerInventory[resource] || 0) + 1;
                
                // Update inventory display
                updateInventoryDisplay();
                
                // Remove block from chunk data
                delete chunk.blockPositions[posKey];
                
                // Record this modification 
                recordChunkModification(blockPosition.x, blockPosition.y, blockPosition.z, 'remove');
                
                // Find and remove the actual block mesh from the scene
                // We need to search through all the children of the chunk group
                for (let i = chunk.children.length - 1; i >= 0; i--) {
                    const blockMesh = chunk.children[i];
                    // Check if this mesh is at the same position as our target block
                    if (Math.abs(blockMesh.position.x - blockPosition.x) < 0.1 && 
                        Math.abs(blockMesh.position.y - blockPosition.y) < 0.1 && 
                        Math.abs(blockMesh.position.z - blockPosition.z) < 0.1) {
                        // Remove this mesh from the scene
                        chunk.remove(blockMesh);
                        break; // We found and removed the block, so stop searching
                    }
                }
                
                console.log(`Removed block of type ${blockType} at ${posKey}, added to inventory`);
            } else {
                console.log("No block data found at position:", posKey);
            }
        }
        
        // Place a block
        function placeBlock(intersection) {
            const { point, normal, chunk } = intersection;
            const x = Math.round(point.x + normal.x * 0.5);
            const y = Math.round(point.y + normal.y * 0.5);
            const z = Math.round(point.z + normal.z * 0.5);
            
            // Don't place inside player
            const playerPos = camera.position;
            if (Math.abs(x - playerPos.x) < 1 && 
                Math.abs(y - playerPos.y) < 2 && 
                Math.abs(z - playerPos.z) < 1) {
                return;
            }
            
            // Check if we have the resource in inventory
            if (playerInventory[selectedBlockType] && playerInventory[selectedBlockType] > 0) {
                // Deduct resource from inventory
                playerInventory[selectedBlockType]--;
                
                // Update inventory display
                updateInventoryDisplay();
                
                // Add block to chunk data
                const posKey = `${x},${y},${z}`;
                if (!chunk.blockPositions[posKey]) {
                    chunk.blockPositions[posKey] = {
                        type: selectedBlockType,
                        index: Object.keys(chunk.blockPositions).length
                    };
                    
                    // Record this modification
                    recordChunkModification(x, y, z, 'add', selectedBlockType);
                    
                    // Create the block in the world
                    const material = blockMaterials[selectedBlockType] || blockMaterials.stone;
                    const mesh = new THREE.Mesh(blockGeometry, material.clone());
                    mesh.position.set(x, y, z);
                    chunk.add(mesh);
                }
            } else {
                console.log("Not enough resources to place this block");
            }
        }
        
        // Update player physics (optimized) with falling detection
        function updatePlayer(delta) {
            if (!isGameStarted) return;
            
            // Store previous position for direction calculation
            previousPlayerPosition.copy(player.position);
            
            // Check if player fell out of the world - add a more reliable threshold and logging
            if (player.position.y < -20) { // Lowered from -10 to -20 to give more leeway
                console.log("Player fell out of the world, respawning...");
                // Reset player position to safe spawn point
                player.isSpawning = true;
                findSafeSpawnPoint();
                generateTerrain();
                player.velocity.set(0, 0, 0);
                return;
            }
            
            // Store previous position to detect sudden large changes
            const previousY = player.position.y;
            
            // Apply gravity
            if (!isPlayerOnGround()) {
                player.velocity.y -= 20 * delta; // Gravity
            } else if (player.velocity.y < 0) {
                player.velocity.y = 0;
            }
            
            // Cap falling speed
            if (player.velocity.y < -30) {
                player.velocity.y = -30;
            }
            
            // Handle jump with improved tracking and button interference prevention
            if (isGameStarted && (keyboard[' '] || keyboard['arrowup']) && isPlayerOnGround()) {
                player.velocity.y = 8;
                player.jumpTime = performance.now();
                player.isJumping = true;
                console.log("Jump executed at position:", player.position.y);
                
                // Force focus back to the canvas to prevent UI interference
                const gameCanvas = document.querySelector('canvas');
                if (gameCanvas) {
                    gameCanvas.focus();
                }
            }
            
            // Movement direction based on camera orientation
            const moveDirection = new THREE.Vector3();
            const cameraDirection = controls.getDirection(new THREE.Vector3());
            cameraDirection.y = 0; // Keep movement on horizontal plane
            cameraDirection.normalize();
            
            const speedMultiplier = keyboard.shift ? 1.5 : 1.0; // Sprint with shift
            
            if (keyboard['w'] || keyboard['arrowup']) {
                moveDirection.add(cameraDirection);
            }
            if (keyboard['s'] || keyboard['arrowdown']) {
                moveDirection.sub(cameraDirection);
            }
            
            const cameraSide = new THREE.Vector3();
            cameraSide.crossVectors(camera.up, cameraDirection).normalize();
            
            if (keyboard['a'] || keyboard['arrowleft']) {
                moveDirection.add(cameraSide);
            }
            if (keyboard['d'] || keyboard['arrowright']) {
                moveDirection.sub(cameraSide);
            }
            
            // Apply movement with collision detection
            if (moveDirection.length() > 0) {
                moveDirection.normalize();
                moveDirection.multiplyScalar(5 * speedMultiplier * delta); // Speed
                movePlayerWithCollision(moveDirection);
            }
            
            // Apply vertical velocity
            movePlayerWithCollision(new THREE.Vector3(0, player.velocity.y * delta, 0));
            
            // Update camera position
            camera.position.copy(player.position);
            camera.position.y += 1.7; // Player height (eyes)
            
            // Check if terrain needs to be updated
            const playerChunkX = Math.floor(player.position.x / chunkSize);
            const playerChunkZ = Math.floor(player.position.z / chunkSize);
            
            // Track very large changes in position for chunk management
            if (!player.lastGlobalX) player.lastGlobalX = player.position.x;
            if (!player.lastGlobalZ) player.lastGlobalZ = player.position.z;
            
            // If player has moved a large distance, reset terrain completely
            const distanceMoved = Math.sqrt(
                Math.pow(player.position.x - player.lastGlobalX, 2) +
                Math.pow(player.position.z - player.lastGlobalZ, 2)
            );
            
            if (distanceMoved > chunkSize * chunkRenderDistance.maximum * 2) {
                console.log("Player moved a large distance, resetting terrain completely");
                player.lastGlobalX = player.position.x;
                player.lastGlobalZ = player.position.z;
                
                // Clear all chunks and regenerate terrain
                Object.keys(terrain).forEach(chunkKey => {
                    disposeChunk(terrain[chunkKey]);
                    scene.remove(terrain[chunkKey]);
                    delete terrain[chunkKey];
                });
                
                // Clear loading queue
                chunkLoadingQueue = [];
                
                // Regenerate immediately
                generateTerrain();
            }
            // Normal chunk update when player moves to a new chunk
            else if (playerChunkX !== player.lastChunkX || playerChunkZ !== player.lastChunkZ) {
                console.log(`Player moved to new chunk: ${playerChunkX},${playerChunkZ} (from ${player.lastChunkX},${player.lastChunkZ})`);
                player.lastChunkX = playerChunkX;
                player.lastChunkZ = playerChunkZ;
                generateTerrain();
            }
        }
        
        // Check if player is on ground
        function isPlayerOnGround() {
            const pos = player.position.clone();
            
            // Check slightly below feet with multiple sample points for more reliable detection
            pos.y -= 0.1;
            
            // Center point check
            if (isPositionSolid(pos)) return true;
            
            // Check a few points around the player for more reliable ground detection
            const checkDistance = 0.25;
            const checkPoints = [
                new THREE.Vector3(pos.x + checkDistance, pos.y, pos.z),
                new THREE.Vector3(pos.x - checkDistance, pos.y, pos.z),
                new THREE.Vector3(pos.x, pos.y, pos.z + checkDistance),
                new THREE.Vector3(pos.x, pos.y, pos.z - checkDistance)
            ];
            
            for (const point of checkPoints) {
                if (isPositionSolid(point)) return true;
            }
            
            return false;
        }

        // Move player with collision detection
        function movePlayerWithCollision(moveVector) {
            // X-axis movement
            if (moveVector.x !== 0) {
                player.position.x += moveVector.x;
                
                // Check for collision in X direction
                if (isPlayerColliding()) {
                    player.position.x -= moveVector.x;
                }
            }
            
            // Y-axis movement with improved handling
            if (moveVector.y !== 0) {
                // Get current position before moving
                const beforeY = player.position.y;
                
                // Apply movement
                player.position.y += moveVector.y;
                
                // Check for collision in Y direction
                if (isPlayerColliding()) {
                    player.position.y = beforeY; // Restore exact previous position
                    player.velocity.y = 0;
                }
                
                // Safety check - don't allow extreme changes in Y position
                if (Math.abs(player.position.y - beforeY) > 10 && !player.isSpawning) {
                    console.log("Prevented extreme Y position change:", beforeY, "->", player.position.y);
                    player.position.y = beforeY;
                    player.velocity.y = 0;
                }
            }
            
            // Z-axis movement
            if (moveVector.z !== 0) {
                player.position.z += moveVector.z;
                
                // Check for collision in Z direction
                if (isPlayerColliding()) {
                    player.position.z -= moveVector.z;
                }
            }
        }
        
        // Check if player is colliding with blocks
        function isPlayerColliding() {
            // Player collision box
            const playerBox = new THREE.Box3(
                new THREE.Vector3(
                    player.position.x - 0.3,
                    player.position.y,
                    player.position.z - 0.3
                ),
                new THREE.Vector3(
                    player.position.x + 0.3,
                    player.position.y + 1.7,
                    player.position.z + 0.3
                )
            );
            
            // Check each corner of the player box
            for (let x = -1; x <= 1; x += 2) {
                for (let y = 0; y <= 1; y += 1) {
                    for (let z = -1; z <= 1; z += 2) {
                        const checkPos = new THREE.Vector3(
                            player.position.x + x * 0.3,
                            player.position.y + y * 1.7,
                            player.position.z + z * 0.3
                        );
                        
                        if (isPositionSolid(checkPos)) {
                    return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // Check if a position is inside a solid block
        function isPositionSolid(position) {
            const blockX = Math.floor(position.x + 0.5);
            const blockY = Math.floor(position.y);
            const blockZ = Math.floor(position.z + 0.5);
            const posKey = `${blockX},${blockY},${blockZ}`;
            
            // Check all chunks
            for (const chunk of Object.values(terrain)) {
                if (chunk.blockPositions[posKey]) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Update day/night cycle with realistic sky colors
        function updateDayNightCycle(delta) {
            dayNightCycle.time += delta;
            
            if (dayNightCycle.time > dayNightCycle.duration) {
                dayNightCycle.time = 0;
                dayNightCycle.isDay = !dayNightCycle.isDay;
            }
            
            // Calculate cycle progress (0 to 1)
            const cycleProgress = (dayNightCycle.time / dayNightCycle.duration);
            
            // Day-night transition based on cycle progress
            if (dayNightCycle.isDay) {
                // Day colors with better transitions
                const lightIntensity = 1.0 - 0.7 * cycleProgress; // Dim as day progresses
                dayNightCycle.directionalLight.intensity = lightIntensity;
                
                // Warmer morning, cooler evening
                if (cycleProgress < 0.5) {
                    // Morning - warmer light
                    dayNightCycle.directionalLight.color.setHex(0xFFEAC3);
                } else {
                    // Evening - cooler light
                    dayNightCycle.directionalLight.color.setHex(0xE0E8FF);
                }
                
                // Sky color - gradually shift from bright blue to darker blue
                const skyColor = new THREE.Color(
                    0.6 - 0.3 * cycleProgress,
                    0.85 - 0.4 * cycleProgress,
                    0.99 - 0.3 * cycleProgress
                );
                scene.background = skyColor;
                scene.fog.color = skyColor;
            } else {
                // Night colors
                const lightIntensity = 0.2 + 0.8 * cycleProgress; // Brighten as night progresses
                dayNightCycle.directionalLight.intensity = lightIntensity;
                
                // Cooler night, warmer pre-dawn
                if (cycleProgress < 0.7) {
                    // Night - blue light
                    dayNightCycle.directionalLight.color.setHex(0xA0B0FF);
                } else {
                    // Pre-dawn - warmer light
                    dayNightCycle.directionalLight.color.setHex(0xFFD8A0);
                }
                
                // Sky color - gradually shift from dark blue to morning blue
                const skyColor = new THREE.Color(
                    0.05 + 0.55 * cycleProgress,
                    0.05 + 0.80 * cycleProgress,
                    0.15 + 0.84 * cycleProgress
                );
                scene.background = skyColor;
                scene.fog.color = skyColor;
            }
        }
        
        // Main animation loop with FPS optimization
        function animate() {
            requestAnimationFrame(animate);
            
            // FPS calculation
            const now = performance.now();
            framesThisSecond++;
            
            if (now > lastFpsUpdate + 1000) {
                fpsDisplay.textContent = `FPS: ${framesThisSecond}`;
                framesThisSecond = 0;
                lastFpsUpdate = now;
                
                // Update chunk count in the stats display
                if (chunkCountDisplay) {
                    chunkCountDisplay.textContent = `Chunks: ${Object.keys(terrain).length}`;
                }
            }
            
            const delta = Math.min(clock.getDelta(), 0.1); // Cap delta time to prevent jumps
            
            // Update player physics
            updatePlayer(delta);
            
            // Update chunk fade transitions
            updateChunkFades(delta);
            
            // Try to process the next chunk in the queue (if we're not already processing one)
            if (!processingChunk && chunkLoadingQueue.length > 0) {
                processChunkQueue();
            }
            
            // Update day/night cycle
            updateDayNightCycle(delta);
            
            // Update block highlighting
            updateBlockHighlight();
            
            // Only render if the game is active
            if (isGameStarted) {
            renderer.render(scene, camera);
            }
            
            // Update block selector based on inventory changes
            updateBlockSelector();
        }

        // Initialize the game when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            console.log("DOM loaded, initializing game");
            try {
                init();
            } catch (e) {
                console.error("Error initializing game:", e);
            }
        });

        // Initialize crafting system
        function initCraftingSystem() {
            // Create crafting grid slots
            const craftingGridElement = document.getElementById('craftingGrid');
            craftingGridElement.innerHTML = '';
            
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    const slot = document.createElement('div');
                    slot.className = 'craftingSlot';
                    slot.dataset.x = x;
                    slot.dataset.y = y;
                    slot.addEventListener('click', () => handleCraftingSlotClick(x, y));
                    craftingGridElement.appendChild(slot);
                }
            }
            
            // Create inventory slots
            updateInventoryGrid();
            
            // Set up crafting buttons
            document.getElementById('craftBtn').addEventListener('click', handleCraft);
            document.getElementById('clearBtn').addEventListener('click', clearCraftingGrid);
            document.getElementById('closeCraftingBtn').addEventListener('click', toggleCraftingUI);
            
            // Create simple inventory display (always visible)
            updateInventoryDisplay();
            
            // Add keyboard shortcut for crafting
            document.addEventListener('keydown', (event) => {
                if (event.key === 'e' && isGameStarted) {
                    event.preventDefault();
                    toggleCraftingUI();
                }
            });
        }
        
        // Toggle crafting UI visibility
        function toggleCraftingUI() {
            isCraftingOpen = !isCraftingOpen;
            document.getElementById('craftingUI').style.display = isCraftingOpen ? 'block' : 'none';
            
            if (isCraftingOpen) {
                controls.unlock();
                // Update inventory when opening
                updateInventoryGrid();
            } else {
                // Clear any selected item
                selectedInventorySlot = null;
                document.body.style.cursor = 'default';
                // Return to game
                controls.lock();
            }
        }
        
        // Update the inventory grid in the crafting UI
        function updateInventoryGrid() {
            const inventoryGridElement = document.getElementById('inventoryGrid');
            inventoryGridElement.innerHTML = '';
            
            // Only show items with quantity > 0
            const inventoryItems = Object.entries(playerInventory)
                .filter(([item, quantity]) => quantity > 0);
            
            for (const [item, quantity] of inventoryItems) {
                const slot = document.createElement('div');
                slot.className = 'inventorySlot';
                slot.dataset.item = item;
                
                const itemElement = document.createElement('div');
                itemElement.className = 'slotItem';
                
                // Use custom render function if available, otherwise use simple color
                if (itemProperties[item].render) {
                    itemProperties[item].render(itemElement);
                } else {
                    itemElement.style.backgroundColor = itemProperties[item].color;
                }
                
                const quantityElement = document.createElement('div');
                quantityElement.className = 'slotQuantity';
                quantityElement.textContent = quantity;
                
                slot.appendChild(itemElement);
                slot.appendChild(quantityElement);
                slot.addEventListener('click', () => handleInventorySlotClick(item));
                
                inventoryGridElement.appendChild(slot);
            }
        }
        
        // Update the simple inventory display (always visible)
        function updateInventoryDisplay() {
            const inventoryDisplayElement = document.getElementById('inventoryDisplay');
            inventoryDisplayElement.innerHTML = '';
            
            // Show all available materials in the player's inventory
            // Get all items that the player has at least one of
            const availableItems = Object.entries(playerInventory)
                .filter(([item, quantity]) => quantity > 0)
                .map(([item]) => item);
            
            // Materials to prioritize at the beginning of the display
            const priorityItems = ['wood', 'stone', 'dirt', 'grass', 'sand', 'snow'];
            
            // Sort items so priority items come first, then alphabetical
            const sortedItems = availableItems.sort((a, b) => {
                const aIndex = priorityItems.indexOf(a);
                const bIndex = priorityItems.indexOf(b);
                
                // If both are priority items, sort by priority list order
                if (aIndex >= 0 && bIndex >= 0) {
                    return aIndex - bIndex;
                }
                // If only a is a priority item, it comes first
                if (aIndex >= 0) return -1;
                // If only b is a priority item, it comes first
                if (bIndex >= 0) return 1;
                // Otherwise alphabetical
                return a.localeCompare(b);
            });
            
            // Add items to the display
            for (const item of sortedItems) {
                // Skip tools and crafted items from the main display
                if (['wooden_pickaxe', 'stone_pickaxe', 'wooden_axe', 'stone_axe', 'crafting_table'].includes(item)) {
                    continue;
                }
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'invItem';
                
                const icon = document.createElement('div');
                icon.className = 'invIcon';
                
                // Make sure we have valid item properties
                if (!itemProperties[item]) {
                    // Add missing item properties
                    itemProperties[item] = {
                        color: getDefaultColorForItem(item),
                        name: formatItemName(item)
                    };
                }
                
                // Use custom render function if available for smaller icon
                if (itemProperties[item].render) {
                    icon.style.position = "relative";
                    icon.style.overflow = "hidden";
                    
                    const miniItem = document.createElement('div');
                    miniItem.style.transformOrigin = "top left";
                    miniItem.style.transform = "scale(0.5)";
                    miniItem.style.width = "40px";
                    miniItem.style.height = "40px";
                    miniItem.style.position = "absolute";
                    
                    itemProperties[item].render(miniItem);
                    icon.appendChild(miniItem);
                } else {
                    icon.style.backgroundColor = itemProperties[item].color;
                }
                
                const count = document.createElement('span');
                count.textContent = playerInventory[item];
                
                itemDiv.appendChild(icon);
                itemDiv.appendChild(count);
                inventoryDisplayElement.appendChild(itemDiv);
            }
        }
        
        // Handle click on crafting slot
        function handleCraftingSlotClick(x, y) {
            if (!selectedInventorySlot) return;
            
            // Check if we have enough of the resource
            if (playerInventory[selectedInventorySlot] > 0) {
                // Place selected item in crafting grid
                craftingGrid[y][x] = selectedInventorySlot;
                
                // Temporarily decrease inventory count (will be restored if crafting is cleared)
                playerInventory[selectedInventorySlot]--;
                
                // Update inventory display
                updateInventoryGrid();
                updateInventoryDisplay();
                
                // Update UI
                updateCraftingGridUI();
                
                // Check for matching recipe
                checkForRecipeMatch();
            }
            
            // Reset selection
            selectedInventorySlot = null;
            
            // Clear selection highlight
            document.querySelectorAll('.inventorySlot').forEach(slot => {
                slot.style.border = '2px solid #777';
            });
        }
        
        // Handle click on inventory slot
        function handleInventorySlotClick(item) {
            // Select or deselect item
            selectedInventorySlot = selectedInventorySlot === item ? null : item;
            
            // Update UI to show selection
            document.querySelectorAll('.inventorySlot').forEach(slot => {
                slot.style.border = slot.dataset.item === selectedInventorySlot 
                    ? '2px solid #ffff00' 
                    : '2px solid #777';
            });
            
            // Add cursor effect to show selected item
            if (selectedInventorySlot) {
                document.body.style.cursor = 'grabbing';
            } else {
                document.body.style.cursor = 'default';
            }
        }
        
        // Update crafting grid UI
        function updateCraftingGridUI() {
            const slots = document.querySelectorAll('.craftingSlot');
            
            slots.forEach(slot => {
                const x = parseInt(slot.dataset.x);
                const y = parseInt(slot.dataset.y);
                const item = craftingGrid[y][x];
                
                // Clear slot
                slot.innerHTML = '';
                slot.classList.remove('filled');
                
                // Add item if exists
                if (item) {
                    const itemElement = document.createElement('div');
                    itemElement.className = 'slotItem';
                    
                    // Use custom render function if available
                    if (itemProperties[item].render) {
                        itemProperties[item].render(itemElement);
                    } else {
                        itemElement.style.backgroundColor = itemProperties[item].color;
                    }
                    
                    slot.appendChild(itemElement);
                    slot.classList.add('filled');
                }
            });
        }
        
        // Check if current crafting grid matches a recipe
        function checkForRecipeMatch() {
            currentRecipeResult = null;
            const craftBtn = document.getElementById('craftBtn');
            const resultSlot = document.getElementById('resultSlot');
            
            // Clear result slot
            resultSlot.innerHTML = '';
            
            // Check each recipe
            for (const recipe of recipes) {
                if (comparePattern(craftingGrid, recipe.pattern)) {
                    currentRecipeResult = recipe.result;
                    
                    // Show result
                    const resultItem = document.createElement('div');
                    resultItem.className = 'slotItem';
                    
                    // Use custom render function if available
                    if (itemProperties[recipe.result.item].render) {
                        itemProperties[recipe.result.item].render(resultItem);
                    } else {
                        resultItem.style.backgroundColor = itemProperties[recipe.result.item].color;
                    }
                    
                    const resultQuantity = document.createElement('div');
                    resultQuantity.className = 'slotQuantity';
                    resultQuantity.textContent = recipe.result.quantity;
                    
                    resultSlot.appendChild(resultItem);
                    resultSlot.appendChild(resultQuantity);
                    
                    // Enable craft button
                    craftBtn.disabled = false;
                    return;
                }
            }
            
            // No match found, disable craft button
            craftBtn.disabled = true;
        }
        
        // Compare crafting grid pattern with recipe pattern
        function comparePattern(grid, pattern) {
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    // Skip if pattern position is null (doesn't matter)
                    if (pattern[y][x] !== null && grid[y][x] !== pattern[y][x]) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        // Handle crafting button click
        function handleCraft() {
            if (!currentRecipeResult) return;
            
            // Add crafted item to inventory
            playerInventory[currentRecipeResult.item] += currentRecipeResult.quantity;
            
            // Consume ingredients from inventory
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    const item = craftingGrid[y][x];
                    if (item) {
                        playerInventory[item]--;
                    }
                }
            }
            
            // Clear crafting grid
            clearCraftingGrid();
            
            // Update UI
            updateInventoryGrid();
            updateInventoryDisplay();
        }
        
        // Clear crafting grid
        function clearCraftingGrid() {
            // Return items from grid to inventory
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    const item = craftingGrid[y][x];
                    if (item) {
                        playerInventory[item]++;
                    }
                }
            }
            
            // Reset grid
            craftingGrid = [
                [null, null, null],
                [null, null, null],
                [null, null, null]
            ];
            
            // Update UI
            updateCraftingGridUI();
            updateInventoryGrid();
            updateInventoryDisplay();
            
            // Clear result
            currentRecipeResult = null;
            document.getElementById('resultSlot').innerHTML = '';
            document.getElementById('craftBtn').disabled = true;
            
            // Reset cursor
            document.body.style.cursor = 'default';
        }

        // Add crafting tools to block selector
        function addCraftedItemsToBlockSelector() {
            const blockSelector = document.getElementById('blockSelector');
            
            // Add crafted items that can be placed
            const placeableItems = ['crafting_table'];
            
            for (const item of placeableItems) {
                // Check if the item is already in the selector
                if (!document.querySelector(`.block-type[data-type="${item}"]`)) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'block-type';
                    itemDiv.dataset.type = item;
                    
                    const preview = document.createElement('div');
                    preview.className = 'block-preview';
                    preview.style.backgroundColor = itemProperties[item].color;
                    
                    const span = document.createElement('span');
                    span.textContent = itemProperties[item].name;
                    
                    itemDiv.appendChild(preview);
                    itemDiv.appendChild(span);
                    
                    itemDiv.addEventListener('click', () => {
                        // Remove selected class from all blocks
                        document.querySelectorAll('.block-type').forEach(el => {
                            el.classList.remove('selected');
                        });
                        
                        // Add selected class to clicked block
                        itemDiv.classList.add('selected');
                        
                        // Update selected block type
                        selectedBlockType = item;
                    });
                    
                    blockSelector.appendChild(itemDiv);
                }
            }
        }
        
        // Automatically update block selector when inventory changes
        function updateBlockSelector() {
            // Update crafting items
            addCraftedItemsToBlockSelector();
            
            // Update visibility based on inventory
            document.querySelectorAll('.block-type').forEach(blockType => {
                const type = blockType.dataset.type;
                // If this is a craftable item, show it only if we have it
                if (['crafting_table', 'wooden_pickaxe', 'stone_pickaxe'].includes(type)) {
                    blockType.style.display = playerInventory[type] > 0 ? 'flex' : 'none';
                }
            });
        }

        // Helper function to get a default color for items that may not be defined
        function getDefaultColorForItem(item) {
            // Default colors for common materials
            const defaultColors = {
                grass: "#3A9D23",
                dirt: "#59472B",
                stone: "#666666",
                sand: "#DBC681",
                sand_light: "#E8D9A0",
                sand_red: "#C2A477",
                sand_gold: "#D4B16A",
                sand_dark: "#B49B6C",
                wood: "#52341D",
                snow: "#F5F5F5",
                water: "#1A45A5",
                cactus: "#2D742F",
                stick: "#8B5A2B"
            };
            
            return defaultColors[item] || "#AAAAAA"; // Default gray for unknown items
        }

        // Helper function to format item name for display
        function formatItemName(item) {
            return item.split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        // Add this new function
        function initHighlightBox() {
            // Create wireframe geometry for the highlight box
            const geometry = new THREE.BoxGeometry(1.01, 1.01, 1.01);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });
            
            highlightBox = new THREE.LineSegments(edges, material);
            highlightBox.visible = false;
            scene.add(highlightBox);
            
            console.log("Highlight box initialized");
        }

        // Add this new function to handle the highlight updates
        function updateBlockHighlight() {
            if (!isGameStarted || isCraftingOpen) {
                // Hide highlight when game is not started or crafting UI is open
                if (highlightBox) highlightBox.visible = false;
                return;
            }
            
            // Cast ray from camera
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            
            // Find all intersections with terrain chunks
            const intersections = [];
            Object.values(terrain).forEach(chunk => {
                // We need to check each block in the chunk
                for (const [posKey, blockData] of Object.entries(chunk.blockPositions)) {
                    const [x, y, z] = posKey.split(',').map(Number);
                    const blockBox = new THREE.Box3(
                        new THREE.Vector3(x - 0.5, y - 0.5, z - 0.5),
                        new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5)
                    );
                    
                    // Check for intersection with this block
                    const intersect = raycaster.ray.intersectBox(blockBox, new THREE.Vector3());
                    if (intersect) {
                        intersections.push({
                            distance: intersect.distanceTo(camera.position),
                            point: intersect.clone(),
                            normal: raycaster.ray.direction.clone().negate(),
                            blockPosition: { x, y, z },
                            chunk: chunk,
                            blockData: blockData
                        });
                    }
                }
            });
            
            // Sort by distance
            intersections.sort((a, b) => a.distance - b.distance);
            
            if (intersections.length > 0 && intersections[0].distance < 5) {
                // We have a target block in range
                const target = intersections[0];
                
                // Position the highlight box at the target block position
                highlightBox.position.set(
                    target.blockPosition.x,
                    target.blockPosition.y,
                    target.blockPosition.z
                );
                
                // Change highlight color based on action (left click = break, right click = place)
                if (keyboard.shift) {
                    // Special color when shift is held (could indicate special action)
                    highlightBox.material.color.setHex(0xff3333);
                } else {
                    // Regular highlight
                    highlightBox.material.color.setHex(0xffffff);
                }
                
                // Make highlight visible
                highlightBox.visible = true;
                
                // Optional: pulse effect for the highlight
                const pulse = 0.8 + 0.2 * Math.sin(performance.now() * 0.005);
                highlightBox.material.opacity = pulse;
            } else {
                // No target block, hide the highlight
                highlightBox.visible = false;
            }
        }

        // Optional: Add highlight color change on mouse down for better feedback
        document.addEventListener('mousedown', function(event) {
            if (!highlightBox || !highlightBox.visible) return;
            
            if (event.button === 0) {
                // Left click - breaking block
                highlightBox.material.color.setHex(0xff3333); // Red for breaking
            } else if (event.button === 2) {
                // Right click - placing block
                highlightBox.material.color.setHex(0x33ff33); // Green for placing
            }
        });

        document.addEventListener('mouseup', function() {
            if (!highlightBox || !highlightBox.visible) return;
            // Reset color on mouse up
            highlightBox.material.color.setHex(0xffffff);
        });

        // Add this to the global variables section
        let fpsDisplay;
        let lastFpsUpdate = 0;
        let framesThisSecond = 0;
        let memoryDisplay;
        let lastMemoryUpdate = 0;
        let chunkCountDisplay;

        // Add this function to init() before the end
        function createFpsCounter() {
            // Create stats container
            const statsContainer = document.createElement('div');
            statsContainer.id = 'statsContainer';
            statsContainer.style.position = 'fixed';
            statsContainer.style.top = '10px';
            statsContainer.style.left = '10px';
            statsContainer.style.background = 'rgba(0, 0, 0, 0.7)';
            statsContainer.style.color = '#00FF00';
            statsContainer.style.padding = '5px 10px';
            statsContainer.style.borderRadius = '5px';
            statsContainer.style.fontFamily = 'monospace';
            statsContainer.style.fontSize = '14px';
            statsContainer.style.fontWeight = 'bold';
            statsContainer.style.zIndex = '9999';
            statsContainer.style.display = 'flex';
            statsContainer.style.flexDirection = 'column';
            statsContainer.style.gap = '5px';
            document.body.appendChild(statsContainer);
            
            // FPS display
            fpsDisplay = document.createElement('div');
            fpsDisplay.textContent = 'FPS: 0';
            statsContainer.appendChild(fpsDisplay);
            
            // Memory usage display
            memoryDisplay = document.createElement('div');
            memoryDisplay.textContent = 'Memory: N/A';
            statsContainer.appendChild(memoryDisplay);
            
            // Chunk count display
            chunkCountDisplay = document.createElement('div');
            chunkCountDisplay.textContent = 'Chunks: 0';
            statsContainer.appendChild(chunkCountDisplay);
            
            // Queue display
            const queueDisplay = document.createElement('div');
            queueDisplay.id = 'queueDisplay';
            queueDisplay.textContent = 'Queue: 0';
            statsContainer.appendChild(queueDisplay);
            
            // Cache display
            const cacheDisplay = document.createElement('div');
            cacheDisplay.id = 'cacheDisplay';
            cacheDisplay.textContent = 'Cached: 0';
            statsContainer.appendChild(cacheDisplay);
            
            // Performance mode toggle button
            const perfButton = document.createElement('button');
            perfButton.textContent = 'High Performance Mode';
            perfButton.style.marginTop = '5px';
            perfButton.style.background = '#333';
            perfButton.style.color = 'white';
            perfButton.style.border = '1px solid #555';
            perfButton.style.borderRadius = '3px';
            perfButton.style.cursor = 'pointer';
            perfButton.style.padding = '3px 6px';
            perfButton.style.fontSize = '12px';
            
            let highPerfMode = false;
            perfButton.addEventListener('click', () => {
                highPerfMode = !highPerfMode;
                
                if (highPerfMode) {
                    // Reduce render distances for better performance
                    chunkRenderDistance.minimum = 1;
                    chunkRenderDistance.ideal = 1;
                    chunkRenderDistance.maximum = 2;
                    chunkRenderDistance.preloadFar = 2;
                    maxCachedChunks = 100; // Reduce cache size in performance mode
                    
                    // Reduce fog distance
                    scene.fog.near = 10;
                    scene.fog.far = 30;
                    perfButton.textContent = 'Normal Mode';
                    perfButton.style.background = '#553300';
                } else {
                    // Restore normal settings
                    chunkRenderDistance.minimum = 1;
                    chunkRenderDistance.ideal = 2;
                    chunkRenderDistance.maximum = 3;
                    chunkRenderDistance.preloadFar = 4;
                    maxCachedChunks = 500; // Normal cache size
                    
                    // Restore fog
                    scene.fog.near = 15;
                    scene.fog.far = 45;
                    perfButton.textContent = 'High Performance Mode';
                    perfButton.style.background = '#333';
                }
                
                // Force terrain update with new render distances
                generateTerrain();
            });
            
            statsContainer.appendChild(perfButton);
            
            // Update stats periodically
            setInterval(() => {
                updateMemoryStats();
                
                // Update queue display
                if (document.getElementById('queueDisplay')) {
                    document.getElementById('queueDisplay').textContent = `Queue: ${chunkLoadingQueue.length}`;
                }
                
                // Update cache display
                if (document.getElementById('cacheDisplay')) {
                    document.getElementById('cacheDisplay').textContent = `Cached: ${Object.keys(chunkCache).length}`;
                }
            }, 1000);
        }
        
        // Function to update memory statistics
        function updateMemoryStats() {
            if (!memoryDisplay || !chunkCountDisplay) return;
            
            // Update chunk count
            const chunkCount = Object.keys(terrain).length;
            chunkCountDisplay.textContent = `Chunks: ${chunkCount}`;
            
            // Update memory usage if available
            if (window.performance && window.performance.memory) {
                const memUsed = Math.round(window.performance.memory.usedJSHeapSize / 1048576);
                const memTotal = Math.round(window.performance.memory.jsHeapSizeLimit / 1048576);
                memoryDisplay.textContent = `Memory: ${memUsed}MB / ${memTotal}MB`;
                
                // Change color based on memory usage
                const memPercentage = memUsed / memTotal;
                if (memPercentage > 0.8) {
                    memoryDisplay.style.color = '#FF5555'; // Red for high usage
                } else if (memPercentage > 0.6) {
                    memoryDisplay.style.color = '#FFAA55'; // Orange for medium usage
                } else {
                    memoryDisplay.style.color = '#55FF55'; // Green for low usage
                }
            } else {
                memoryDisplay.textContent = 'Memory: N/A';
            }
        }

        // Enhanced Chunk class with expanded LOD system
        class Chunk {
            constructor(x, z, size = 16) {
                this.position = new THREE.Vector3(x * size, 0, z * size);
                this.size = size;
                this.blockData = {};  // Stores block types by position
                this.lodMeshes = {
                    0: {}, // Ultra detail: 1x1x1 blocks (0-16 units)
                    1: {}, // High detail: 2x2x2 blocks (16-32 units)
                    2: {}, // Medium detail: 4x4x4 blocks (32-64 units)
                    3: {}, // Low detail: 8x8x8 blocks (64-128 units)
                    4: {}  // Ultra low detail: 16x16x1 blocks (128+ units, terrain only)
                };
                this.group = new THREE.Group();
                this.group.position.copy(this.position);
                this.isDirty = false; // Flag for chunks that need rebuilding
                this.lastLODLevel = -1; // Track current LOD level
                
                // Center point for distance calculations
                this.center = new THREE.Vector3(
                    this.position.x + this.size / 2,
                    this.position.y + this.size / 2,
                    this.position.z + this.size / 2
                );
            }
            
            // Add a block to the chunk data
            addBlock(localX, y, localZ, blockType) {
                const key = `${localX},${y},${localZ}`;
                this.blockData[key] = blockType;
                this.isDirty = true;
            }
            
            // Remove a block from the chunk
            removeBlock(localX, y, localZ) {
                const key = `${localX},${y},${localZ}`;
                if (this.blockData[key]) {
                    delete this.blockData[key];
                    this.isDirty = true;
                }
            }
            
            // Get block at position
            getBlock(localX, y, localZ) {
                const key = `${localX},${y},${localZ}`;
                return this.blockData[key];
            }
            
            // Update LOD based on camera distance with more levels
            updateLOD(camera) {
                if (this.isDirty) {
                    this.buildMesh();
                    return;
                }
                
                // Calculate distance to camera
                const cameraPosition = camera.position.clone();
                const distanceToCamera = cameraPosition.distanceTo(this.center);
                
                // Determine LOD level based on distance with more granular levels
                let lodLevel = 0; // Ultra detail (closest)
                
                if (distanceToCamera > 128) lodLevel = 4;      // Ultra low detail (furthest)
                else if (distanceToCamera > 64) lodLevel = 3;  // Low detail
                else if (distanceToCamera > 32) lodLevel = 2;  // Medium detail
                else if (distanceToCamera > 16) lodLevel = 1;  // High detail
                
                // Only rebuild if LOD level changed
                if (lodLevel !== this.lastLODLevel) {
                    this.lastLODLevel = lodLevel;
                    this.setLODVisibility(lodLevel);
                }
            }
            
            // Set visibility of appropriate LOD level
            setLODVisibility(lodLevel) {
                // Hide all meshes first
                for (const level in this.lodMeshes) {
                    for (const type in this.lodMeshes[level]) {
                        this.lodMeshes[level][type].visible = false;
                    }
                }
                
                // Show only the current LOD level
                if (this.lodMeshes[lodLevel]) {
                    for (const type in this.lodMeshes[lodLevel]) {
                        this.lodMeshes[lodLevel][type].visible = true;
                    }
                }
            }
            
            // Build all LOD levels with enhanced gradation
            buildMesh() {
                // Clear previous meshes
                for (const level in this.lodMeshes) {
                    for (const type in this.lodMeshes[level]) {
                        this.group.remove(this.lodMeshes[level][type]);
                        this.lodMeshes[level][type].geometry.dispose();
                    }
                }
                this.lodMeshes = {
                    0: {}, // Ultra detail (original)
                    1: {}, // High detail
                    2: {}, // Medium detail
                    3: {}, // Low detail
                    4: {}  // Ultra low detail
                };
                
                // Build LOD levels, only if they might be needed based on render distance
                const renderDistance = 256; // Maximum view distance
                
                this.buildLOD0(); // Always build highest detail
                
                if (renderDistance > 16) this.buildLOD1();
                if (renderDistance > 32) this.buildLOD2();
                if (renderDistance > 64) this.buildLOD3();
                if (renderDistance > 128) this.buildLOD4();
                
                // Set initial visibility based on last LOD level
                this.setLODVisibility(this.lastLODLevel >= 0 ? this.lastLODLevel : 0);
                
                this.isDirty = false;
            }
            
            // Build LOD level 3 (Low detail: 8x8x8 blocks)
            buildLOD3() {
                const blocksByMaterial = this.analyzeBlockDistribution(8);
                
                for (const [blockType, positions] of Object.entries(blocksByMaterial)) {
                    // Skip empty block sets
                    if (positions.length === 0) continue;
                    
                    // Use simpler material for distant blocks (no specular, simple shading)
                    const baseMaterial = blockMaterials[blockType] || blockMaterials.stone;
                    const material = new THREE.MeshLambertMaterial({ 
                        color: baseMaterial.color || new THREE.Color(0x808080),
                        flatShading: true,
                        vertexColors: false,
                        fog: true
                    });
                    
                    // Create simplified geometry
                    const geometry = new THREE.BufferGeometry();
                    const vertices = [];
                    const normals = [];
                    const uvs = [];
                    
                    // Helper to check if a region face should be rendered
                    const shouldRenderFace = (x, y, z, dx, dy, dz, size) => {
                        const nx = x + dx * size;
                        const ny = y + dy * size;
                        const nz = z + dz * size;
                        
                        // Check if the neighboring region contains blocks of a different type
                        for (let ix = 0; ix < size; ix++) {
                            for (let iy = 0; iy < size; iy++) {
                                for (let iz = 0; iz < size; iz++) {
                                    const neighborKey = `${nx+ix},${ny+iy},${nz+iz}`;
                                    const neighborType = this.blockData[neighborKey];
                                    // If the neighbor is air or water, the face is visible
                                    if (!neighborType || neighborType === 'water') {
                                        return true;
                                    }
                                }
                            }
                        }
                        return false;
                    };
                    
                    // Process each merged block
                    positions.forEach(pos => {
                        const { x, y, z } = pos;
                        const size = 8; // 8x8x8 block size
                        
                        // Add faces only if they're visible from outside
                        // Front face
                        if (shouldRenderFace(x, y, z, 0, 0, 1, size)) {
                            vertices.push(
                                x, y, z + size,
                                x + size, y, z + size,
                                x + size, y + size, z + size,
                                x, y + size, z + size
                            );
                            normals.push(...Array(4).fill([0, 0, 1]).flat());
                            uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                        }
                        
                        // Back face
                        if (shouldRenderFace(x, y, z, 0, 0, -1, size)) {
                            vertices.push(
                                x + size, y, z,
                                x, y, z,
                                x, y + size, z,
                                x + size, y + size, z
                            );
                            normals.push(...Array(4).fill([0, 0, -1]).flat());
                            uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                        }
                        
                        // Top face
                        if (shouldRenderFace(x, y, z, 0, 1, 0, size)) {
                            vertices.push(
                                x, y + size, z,
                                x, y + size, z + size,
                                x + size, y + size, z + size,
                                x + size, y + size, z
                            );
                            normals.push(...Array(4).fill([0, 1, 0]).flat());
                            uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                        }
                        
                        // Bottom face
                        if (shouldRenderFace(x, y, z, 0, -1, 0, size)) {
                            vertices.push(
                                x, y, z,
                                x + size, y, z,
                                x + size, y, z + size,
                                x, y, z + size
                            );
                            normals.push(...Array(4).fill([0, -1, 0]).flat());
                            uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                        }
                        
                        // Right face
                        if (shouldRenderFace(x, y, z, 1, 0, 0, size)) {
                            vertices.push(
                                x + size, y, z,
                                x + size, y, z + size,
                                x + size, y + size, z + size,
                                x + size, y + size, z
                            );
                            normals.push(...Array(4).fill([1, 0, 0]).flat());
                            uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                        }
                        
                        // Left face
                        if (shouldRenderFace(x, y, z, -1, 0, 0, size)) {
                            vertices.push(
                                x, y, z + size,
                                x, y, z,
                                x, y + size, z,
                                x, y + size, z + size
                            );
                            normals.push(...Array(4).fill([-1, 0, 0]).flat());
                            uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
                        }
                    });
                    
                    // If no vertices, skip this material
                    if (vertices.length === 0) continue;
                    
                    // Create the geometry
                    const verticesArray = new Float32Array(vertices);
                    const normalsArray = new Float32Array(normals);
                    const uvsArray = new Float32Array(uvs);
                    
                    // Calculate indices
                    const indices = [];
                    for (let i = 0; i < vertices.length / 12; i++) {
                        const baseIndex = i * 4;
                        indices.push(
                            baseIndex, baseIndex + 1, baseIndex + 2,
                            baseIndex, baseIndex + 2, baseIndex + 3
                        );
                    }
                    
                    // Set geometry attributes
                    geometry.setAttribute('position', new THREE.BufferAttribute(verticesArray, 3));
                    geometry.setAttribute('normal', new THREE.BufferAttribute(normalsArray, 3));
                    geometry.setAttribute('uv', new THREE.BufferAttribute(uvsArray, 2));
                    geometry.setIndex(indices);
                    
                    // Create mesh with the merged geometry
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.visible = false; // Initially hidden
                    this.lodMeshes[3][blockType] = mesh;
                    this.group.add(mesh);
                }
            }
            
            // Build LOD level 4 (Ultra low detail: 16x16x1 heightmap style rendering)
            buildLOD4() {
                // For ultra-distant chunks, create a simplified heightmap-style representation
                const heightData = this.generateHeightmap();
                
                // Create a simplified terrain mesh with reduced details
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const normals = [];
                const uvs = [];
                const colors = [];
                
                // Helper colors for different surface types
                const typeColors = {
                    grass: new THREE.Color(0x7CFC00),
                    dirt: new THREE.Color(0x8B4513),
                    stone: new THREE.Color(0x808080),
                    water: new THREE.Color(0x1E90FF),
                    sand: new THREE.Color(0xF4A460),
                    wood: new THREE.Color(0x8B7355),
                    leaves: new THREE.Color(0x228B22)
                };
                
                // Create a terrain-like surface for the top of the chunk
                for (let x = 0; x < this.size; x += 2) {
                    for (let z = 0; z < this.size; z += 2) {
                        const h1 = heightData[x][z];
                        const h2 = heightData[Math.min(x+2, this.size-1)][z];
                        const h3 = heightData[Math.min(x+2, this.size-1)][Math.min(z+2, this.size-1)];
                        const h4 = heightData[x][Math.min(z+2, this.size-1)];
                        
                        const t1 = heightData.types[x][z];
                        const t2 = heightData.types[Math.min(x+2, this.size-1)][z];
                        const t3 = heightData.types[Math.min(x+2, this.size-1)][Math.min(z+2, this.size-1)];
                        const t4 = heightData.types[x][Math.min(z+2, this.size-1)];
                        
                        // Add two triangles to form a quad
                        vertices.push(
                            x, h1, z,
                            x+2, h2, z,
                            x+2, h3, z+2,
                            
                            x, h1, z,
                            x+2, h3, z+2,
                            x, h4, z+2
                        );
                        
                        // Calculate normal for the quad (cross product of two edges)
                        const v1 = new THREE.Vector3(x+2-x, h2-h1, z-z);
                        const v2 = new THREE.Vector3(x+2-x, h3-h1, z+2-z);
                        const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                        
                        // Add the normal 6 times (for each vertex)
                        for (let i = 0; i < 6; i++) {
                            normals.push(normal.x, normal.y, normal.z);
                        }
                        
                        // Add UVs
                        uvs.push(
                            0, 0,
                            1, 0,
                            1, 1,
                            
                            0, 0,
                            1, 1,
                            0, 1
                        );
                        
                        // Add colors based on block types
                        const c1 = typeColors[t1] || typeColors.stone;
                        const c2 = typeColors[t2] || typeColors.stone;
                        const c3 = typeColors[t3] || typeColors.stone;
                        const c4 = typeColors[t4] || typeColors.stone;
                        
                        colors.push(
                            c1.r, c1.g, c1.b,
                            c2.r, c2.g, c2.b,
                            c3.r, c3.g, c3.b,
                            
                            c1.r, c1.g, c1.b,
                            c3.r, c3.g, c3.b,
                            c4.r, c4.g, c4.b
                        );
                    }
                }
                
                // Create the geometry
                const verticesArray = new Float32Array(vertices);
                const normalsArray = new Float32Array(normals);
                const uvsArray = new Float32Array(uvs);
                const colorsArray = new Float32Array(colors);
                
                // Set geometry attributes
                geometry.setAttribute('position', new THREE.BufferAttribute(verticesArray, 3));
                geometry.setAttribute('normal', new THREE.BufferAttribute(normalsArray, 3));
                geometry.setAttribute('uv', new THREE.BufferAttribute(uvsArray, 2));
                geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
                
                // Use a simple material with vertex colors for the terrain
                const material = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    flatShading: true,
                    side: THREE.FrontSide
                });
                
                // Create mesh
                const mesh = new THREE.Mesh(geometry, material);
                mesh.visible = false; // Initially hidden
                this.lodMeshes[4]["terrain"] = mesh;
                this.group.add(mesh);
            }
            
            // Generate a heightmap for the chunk (for ultra-low LOD)
            generateHeightmap() {
                const heightmap = Array(this.size + 1).fill().map(() => Array(this.size + 1).fill(0));
                const typeMap = Array(this.size + 1).fill().map(() => Array(this.size + 1).fill(''));
                
                // Determine highest block at each x,z coordinate
                for (const [posKey, blockType] of Object.entries(this.blockData)) {
                    const [x, y, z] = posKey.split(',').map(Number);
                    
                    if (y > heightmap[x][z]) {
                        heightmap[x][z] = y;
                        typeMap[x][z] = blockType;
                    }
                }
                
                // Return heightmap with types
                return {
                    ...heightmap,
                    types: typeMap
                };
            }
            
            // Helper method to analyze block distribution for LOD
            analyzeBlockDistribution(regionSize) {
                const blocksByMaterial = {};
                const regionStats = {};
                
                // Group the chunk into regions of the specified size
                for (const [posKey, blockType] of Object.entries(this.blockData)) {
                    const [x, y, z] = posKey.split(',').map(Number);
                    
                    // Calculate the region this block belongs to
                    const rx = Math.floor(x / regionSize) * regionSize;
                    const ry = Math.floor(y / regionSize) * regionSize;
                    const rz = Math.floor(z / regionSize) * regionSize;
                    const regionKey = `${rx},${ry},${rz}`;
                    
                    // Initialize region stats if needed
                    if (!regionStats[regionKey]) {
                        regionStats[regionKey] = {
                            counts: {},
                            total: 0,
                            mostCommon: null,
                            mostCommonCount: 0
                        };
                    }
                    
                    // Count block types in this region
                    if (!regionStats[regionKey].counts[blockType]) {
                        regionStats[regionKey].counts[blockType] = 0;
                    }
                    regionStats[regionKey].counts[blockType]++;
                    regionStats[regionKey].total++;
                    
                    // Update most common type if needed
                    if (regionStats[regionKey].counts[blockType] > regionStats[regionKey].mostCommonCount) {
                        regionStats[regionKey].mostCommon = blockType;
                        regionStats[regionKey].mostCommonCount = regionStats[regionKey].counts[blockType];
                    }
                }
                
                // Convert region stats to merged blocks by material
                for (const [regionKey, stats] of Object.entries(regionStats)) {
                    // Skip regions with very few blocks (less than 10% filled)
                    if (stats.total < (regionSize * regionSize * regionSize * 0.1)) {
                        continue;
                    }
                    
                    const [rx, ry, rz] = regionKey.split(',').map(Number);
                    const mostCommonType = stats.mostCommon;
                    
                    // Add this region to the appropriate material group
                    if (!blocksByMaterial[mostCommonType]) {
                        blocksByMaterial[mostCommonType] = [];
                    }
                    blocksByMaterial[mostCommonType].push({
                        x: rx,
                        y: ry,
                        z: rz
                    });
                }
                
                return blocksByMaterial;
            }
        }

        // Chunk management
        let chunks = {};
        const CHUNK_SIZE = 16;

        // Get or create chunk at position
        function getChunkAt(x, z) {
            const chunkX = Math.floor(x / CHUNK_SIZE);
            const chunkZ = Math.floor(z / CHUNK_SIZE);
            const chunkKey = `${chunkX},${chunkZ}`;
            
            if (!chunks[chunkKey]) {
                chunks[chunkKey] = new Chunk(chunkX, chunkZ, CHUNK_SIZE);
                scene.add(chunks[chunkKey].group);
            }
            
            return chunks[chunkKey];
        }

        // Add block to the world using chunk system
        function addBlock(x, y, z, type) {
            const chunk = getChunkAt(x, z);
            const localX = x % CHUNK_SIZE;
            const localZ = z % CHUNK_SIZE;
            chunk.addBlock(localX, y, localZ, type);
        }

        // Remove block from the world
        function removeBlock(x, y, z) {
            const chunk = getChunkAt(x, z);
            const localX = x % CHUNK_SIZE;
            const localZ = z % CHUNK_SIZE;
            chunk.removeBlock(localX, y, localZ);
        }

        // Get block at world position
        function getBlockAt(x, y, z) {
            const chunk = getChunkAt(x, z);
            const localX = x % CHUNK_SIZE;
            const localZ = z % CHUNK_SIZE;
            return chunk.getBlock(localX, y, localZ);
        }

        // Update chunks that need rebuilding
        function updateChunks() {
            let anyChunkDirty = false;
            
            for (const chunk of Object.values(chunks)) {
                if (chunk.isDirty) {
                    chunk.buildMesh();
                    anyChunkDirty = true;
                }
            }
            
            // Return true if any chunk was rebuilt
            return anyChunkDirty;
        }

        // Update LOD for all chunks
        function updateLODForChunks() {
            // Get the current camera position
            const cameraPosition = camera.position.clone();
            
            // Check all chunks and update their LOD based on distance
            for (const chunkKey in chunks) {
                const chunk = chunks[chunkKey];
                chunk.updateLOD(camera);
            }
        }

        // Update the render function to update LOD
        function render() {
            requestAnimationFrame(render);
            
            // Update stats if available
            if (stats) stats.begin();
            
            // Update player physics
            const delta = Math.min(clock.getDelta(), 0.1); // Cap delta time
            updatePlayer(delta);
            
            // Update day-night cycle
            if (isDayNightEnabled) {
                updateDayNightCycle();
            }
            
            // Update LOD for visible chunks
            updateLODForChunks();
            
            // Render scene
            renderer.render(scene, camera);
            
            // Update stats if available
            if (stats) stats.end();
        }

        // Fix for the space key triggering both jump and biome button
        function initializeEventHandlers() {
            // Prevent space key from activating buttons when intended for jumping
            document.addEventListener('keydown', function(event) {
                // Only prevent default space behavior when game is started
                if (event.code === 'Space' && isGameStarted) {
                    event.preventDefault();
                }
            }, { passive: false });
            
            // Focus handling to prevent spacebar from triggering buttons
            const gameCanvas = document.querySelector('canvas');
            if (gameCanvas) {
                // Keep focus on the canvas during gameplay
                gameCanvas.addEventListener('click', function() {
                    this.focus();
                });
                
                // Make canvas focusable
                gameCanvas.tabIndex = 1;
            }
            
            // Ensure buttons use click events rather than keypress
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                // Replace any keyboard listeners with explicit click handlers
                button.addEventListener('click', function(event) {
                    // The existing click handler remains functional
                    // This just ensures we're handling the event properly
                });
                
                // Remove the button from tab navigation during gameplay
                button.addEventListener('focus', function() {
                    if (isGameStarted) {
                        gameCanvas.focus();
                    }
                });
            });
        }

        // Update the initKeyboardControls function to separate game controls from UI
        function initKeyboardControls() {
            // Keyboard controls using a consistent case for keys
            keyboard = {};
            
            // Handle keydown
            document.addEventListener('keydown', function(event) {
                // Convert key to lowercase for consistency
                const key = event.key.toLowerCase();
                keyboard[key] = true;
                
                // Space key jumped event tracking (for debugging)
                if (key === ' ' && isGameStarted) {
                    console.log("Jump initiated by spacebar");
                }
            });
            
            // Handle keyup
            document.addEventListener('keyup', function(event) {
                // Convert key to lowercase for consistency
                const key = event.key.toLowerCase();
                keyboard[key] = false;
            });
        }

        // Update the UI initialization to ensure buttons don't steal focus
        function initUI() {
            // ... existing UI initialization code ...
            
            // Get the biome button specifically
            const biomeButton = document.getElementById('biomeButton');
            if (biomeButton) {
                // Ensure the biome button uses a direct click handler
                biomeButton.addEventListener('click', function(event) {
                    // The actual handler code would be here in the real implementation
                    console.log("Biome button clicked via mouse");
                    // Prevent event bubbling
                    event.stopPropagation();
                });
                
                // Remove default spacebar behavior for this button
                biomeButton.addEventListener('keydown', function(event) {
                    if (event.code === 'Space') {
                        // Prevent spacebar from activating this button
                        event.preventDefault();
                        // Stop propagation to prevent jump
                        event.stopPropagation();
                    }
                });
            }
            
            // Call the new event handler initializer
            initializeEventHandlers();
        }

        // Modify the game start function to set focus properly
        function startGame() {
            isGameStarted = true;
            
            // Hide menu and show game UI
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            
            // Initialize game systems
            initThree();
            initKeyboardControls();
            initUI();
            
            // Focus the canvas to receive keyboard events properly
            const gameCanvas = document.querySelector('canvas');
            if (gameCanvas) {
                gameCanvas.focus();
            }
            
            // Start the game loop
            animate();
        }

        // Enhanced fix for spacebar triggering both jump and button clicks
        document.addEventListener('DOMContentLoaded', function() {
            // Global event capture for spacebar to prevent button activation
            document.addEventListener('keydown', function(event) {
                // Check if the game has started and it's a spacebar event
                if (isGameStarted && (event.code === 'Space' || event.key === ' ')) {
                    // Prevent the default action (button activation)
                    event.preventDefault();
                    
                    // Stop the event from propagating to other listeners
                    event.stopPropagation();
                    
                    // Manually set the keyboard state for jump processing
                    keyboard[' '] = true;
                    
                    // Return false to ensure the event is fully canceled
                    return false;
                }
            }, true); // The 'true' enables capturing phase, intercepting events before they reach elements
            
            // Handle spacebar release for jump controls
            document.addEventListener('keyup', function(event) {
                if (isGameStarted && (event.code === 'Space' || event.key === ' ')) {
                    // Prevent any default action
                    event.preventDefault();
                    
                    // Update keyboard state
                    keyboard[' '] = false;
                    
                    // Stop propagation
                    event.stopPropagation();
                    return false;
                }
            }, true);
            
            // Button handling - prevent spacebar from activating buttons
            const allButtons = document.querySelectorAll('button');
            allButtons.forEach(button => {
                // Disable spacebar activation on all buttons
                button.addEventListener('keydown', function(event) {
                    if (event.code === 'Space' || event.key === ' ') {
                        event.preventDefault();
                        event.stopPropagation();
                        return false;
                    }
                }, true);
                
                // Disable button focus when game is active
                button.addEventListener('focus', function() {
                    if (isGameStarted) {
                        this.blur(); // Remove focus from the button
                        
                        // Refocus on the game area
                        const gameCanvas = document.querySelector('canvas');
                        if (gameCanvas) {
                            gameCanvas.focus();
                        }
                    }
                });
            });
            
            // Fix for the specific biome button
            const biomeButton = document.getElementById('biomeButton');
            if (biomeButton) {
                // Replace any existing click handlers with a manual one that won't trigger on spacebar
                const originalClickHandler = biomeButton.onclick;
                biomeButton.onclick = null; // Remove inline handler if present
                
                // Create new handler that doesn't respond to keyboard events
                biomeButton.addEventListener('click', function(event) {
                    // Only process actual mouse clicks, not keyboard-triggered clicks
                    if (event.isTrusted && event.type === 'click' && !event.detail.fromKeyboard) {
                        // Call original handler if it existed
                        if (typeof originalClickHandler === 'function') {
                            originalClickHandler.call(this, event);
                        }
                    }
                });
            }
        });

        // Modify keyboard initialization to ensure clean state
        function initKeyboardControls() {
            // Reset keyboard state
            keyboard = {};
            
            // Handle regular keydown events for movement keys
            document.addEventListener('keydown', function(event) {
                const key = event.key.toLowerCase();
                
                // Skip spacebar as it's handled by the global handler
                if (key !== ' ') {
                    keyboard[key] = true;
                }
            });
            
            // Handle regular keyup for movement keys
            document.addEventListener('keyup', function(event) {
                const key = event.key.toLowerCase();
                
                // Skip spacebar as it's handled by the global handler
                if (key !== ' ') {
                    keyboard[key] = false;
                }
            });
        }

        // Add a utility function to set focus on the game canvas
        function focusGameCanvas() {
            if (!isGameStarted) return;
            
            const gameCanvas = document.querySelector('canvas');
            if (gameCanvas) {
                gameCanvas.focus();
                
                // Make sure no buttons have focus
                document.querySelectorAll('button').forEach(button => {
                    button.blur();
                });
            }
        }

        // Call focus function after the renderer is created
        function initThree() {
            // ... existing initThree code ...
            
            // Add this at the end of the function
            setTimeout(focusGameCanvas, 100); // Short delay to ensure everything is ready
        }

        // Also call focus on window focus events
        window.addEventListener('focus', function() {
            if (isGameStarted) {
                focusGameCanvas();
            }
        });

        function setupHighlyOptimizedLights() {
            // Create a performance-aware lighting system
            const hardwareLevel = estimateHardwarePerformance();
            const isMobile = /Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent);
            
            // Create directional light with adaptive quality
            const directionalLight = new THREE.DirectionalLight(0xFFEAC3, 1.2);
            directionalLight.position.set(100, 100, 50);
            
            // Adaptive shadow quality based on hardware
            directionalLight.castShadow = hardwareLevel > 2; // Only enable shadows on medium-high hardware
            
            // Optimize shadow map size based on hardware capability
            const shadowMapSize = isMobile ? 512 : 
                                 (hardwareLevel >= 4 ? 2048 : 
                                 (hardwareLevel >= 3 ? 1024 : 512));
            
            directionalLight.shadow.mapSize.width = shadowMapSize;
            directionalLight.shadow.mapSize.height = shadowMapSize;
            
            // Optimize shadow camera frustum
            const shadowSize = 120; // Area covered by shadow
            directionalLight.shadow.camera.left = -shadowSize / 2;
            directionalLight.shadow.camera.right = shadowSize / 2;
            directionalLight.shadow.camera.top = shadowSize / 2;
            directionalLight.shadow.camera.bottom = -shadowSize / 2;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 350; // Reduced from 500
            
            // Optimize shadow bias to reduce artifacts
            directionalLight.shadow.bias = -0.001;
            
            // Use VSM shadow maps on high-end hardware for better quality
            if (hardwareLevel >= 4) {
                directionalLight.shadow.type = THREE.VSMShadowMap;
            }
            
            // Only update shadow maps every other frame on low-end devices
            if (hardwareLevel <= 2) {
                directionalLight.shadow.autoUpdate = false;
                directionalLight.shadow.needsUpdate = true;
                
                // Set up interval to update shadows periodically
                setInterval(() => {
                    directionalLight.shadow.needsUpdate = true;
                }, 1000 / 20); // Update at 20fps instead of 60fps
            }
            
            scene.add(directionalLight);
            
            // Optimized ambient light
            // Adjust ambient intensity based on hardware to compensate for disabled features
            const ambientIntensity = hardwareLevel <= 2 ? 0.7 : 0.5;
            const ambientLight = new THREE.AmbientLight(0x8097BB, ambientIntensity);
            scene.add(ambientLight);
            
            // For mid-high end hardware, add a very subtle hemispherical light
            // This adds subtle environment lighting at minimal performance cost
            if (hardwareLevel >= 3 && !isMobile) {
                const hemiLight = new THREE.HemisphereLight(
                    0x9BB8FF, // Sky color - slightly blue
                    0x6A5939, // Ground color - earthy tone
                    0.3       // Intensity kept low
                );
                scene.add(hemiLight);
                dayNightCycle.hemiLight = hemiLight;
            }

            // Store lights for day/night cycle
            dayNightCycle.directionalLight = directionalLight;
            dayNightCycle.ambientLight = ambientLight;
            dayNightCycle.shadowUpdateFrequency = hardwareLevel <= 2 ? 3 : 1; // Update shadows every X frames
            dayNightCycle.frameCounter = 0;
            
            console.log(`Lighting optimized for hardware level: ${hardwareLevel}, Shadow map: ${shadowMapSize}px`);
        }

        // Enhanced day/night cycle with optimized updates
        function updateHighlyOptimizedLights(delta) {
            // Update directional light position based on time of day
            const timeOfDay = dayNightCycle.timeOfDay;
            dayNightCycle.frameCounter++;
            
            // Skip shadow updates on some frames for performance
            const shouldUpdateShadows = 
                dayNightCycle.frameCounter % dayNightCycle.shadowUpdateFrequency === 0;
            
            // Update time of day
            dayNightCycle.timeOfDay += delta * dayNightCycle.cycleSpeed;
            if (dayNightCycle.timeOfDay >= 1) dayNightCycle.timeOfDay = 0;
            
            // Smoothly move the sun/moon
            const angle = timeOfDay * Math.PI * 2;
            const height = Math.sin(angle) * 90 + 100; // Higher peak for more realistic arc
            
            // Position the directional light
            dayNightCycle.directionalLight.position.set(
                Math.sin(angle) * 150,
                Math.max(10, height), // Keep light above horizon
                Math.cos(angle) * 150
            );
            
            // Day/night cycle with optimized color transitions
            // Time-based light adjustments
            const isDay = timeOfDay > 0.25 && timeOfDay < 0.75;
            const isSunrise = timeOfDay > 0.2 && timeOfDay < 0.3;
            const isSunset = timeOfDay > 0.7 && timeOfDay < 0.8;
            
            // Only update shadow maps when needed
            if (shouldUpdateShadows && dayNightCycle.directionalLight.shadow) {
                dayNightCycle.directionalLight.shadow.needsUpdate = true;
            }
            
            // Light color and intensity updates
            if (isDay) {
                // Day time
                const noonIntensity = 1.2;
                const noonColor = 0xFFEAC3;
                
                if (isSunrise) {
                    // Sunrise transition
                    const t = (timeOfDay - 0.2) * 10; // 0 to 1 during sunrise
                    dayNightCycle.directionalLight.intensity = lerp(0.5, noonIntensity, t);
                    dayNightCycle.directionalLight.color.setHex(lerpColor(0xFFB08D, noonColor, t));
                } else if (isSunset) {
                    // Sunset transition
                    const t = (timeOfDay - 0.7) * 10; // 0 to 1 during sunset
                    dayNightCycle.directionalLight.intensity = lerp(noonIntensity, 0.5, t);
                    dayNightCycle.directionalLight.color.setHex(lerpColor(noonColor, 0xFFB08D, t));
                } else {
                    // Full day
                    dayNightCycle.directionalLight.intensity = noonIntensity;
                    dayNightCycle.directionalLight.color.setHex(noonColor);
                }
                
                // Ambient light adjustment
                const ambientDayIntensity = 0.5;
                dayNightCycle.ambientLight.intensity = ambientDayIntensity;
                dayNightCycle.ambientLight.color.setHex(0x8097BB);
            } else {
                // Night time - dimmer blue light
                dayNightCycle.directionalLight.intensity = 0.3;
                dayNightCycle.directionalLight.color.setHex(0x8AA0FF);
                
                // Darker ambient at night
                dayNightCycle.ambientLight.intensity = 0.2;
                dayNightCycle.ambientLight.color.setHex(0x3A4B6D);
            }
            
            // Update hemisphere light if present
            if (dayNightCycle.hemiLight) {
                if (isDay) {
                    dayNightCycle.hemiLight.intensity = 0.3;
                } else {
                    dayNightCycle.hemiLight.intensity = 0.1;
                }
            }
            
            // Update sky color based on time
            const skyColor = new THREE.Color();
            if (isDay) {
                if (isSunrise) {
                    const t = (timeOfDay - 0.2) * 10;
                    skyColor.setRGB(
                        lerp(0.2, 0.6, t),
                        lerp(0.2, 0.8, t),
                        lerp(0.4, 1.0, t)
                    );
                } else if (isSunset) {
                    const t = (timeOfDay - 0.7) * 10;
                    skyColor.setRGB(
                        lerp(0.6, 0.3, t),
                        lerp(0.8, 0.3, t),
                        lerp(1.0, 0.5, t)
                    );
                } else {
                    // Full day - blue sky
                    skyColor.setRGB(0.6, 0.8, 1.0);
                }
            } else {
                // Night - dark blue sky
                skyColor.setRGB(0.05, 0.05, 0.15);
            }
            
            // Apply the sky color
            if (scene.background) {
                scene.background.copy(skyColor);
                if (scene.fog && scene.fog.color) {
                    scene.fog.color.copy(skyColor);
                }
            }
        }

        // Helper functions for color and value interpolation
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function lerpColor(colorA, colorB, t) {
            const a = new THREE.Color(colorA);
            const b = new THREE.Color(colorB);
            
            return new THREE.Color(
                a.r + (b.r - a.r) * t,
                a.g + (b.g - a.g) * t,
                a.b + (b.b - a.b) * t
            ).getHex();
        }

        // Add this to your estimateHardwarePerformance function or create it if it doesn't exist
        function estimateHardwarePerformance() {
            let score = 3; // Default medium score
            
            // WebGL detection
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) return 2; // Reduce if WebGL is not available
            
            // Check for WebGL2
            if (canvas.getContext('webgl2')) {
                score += 1;
            }
            
            // Check CPU cores
            if (navigator.hardwareConcurrency) {
                if (navigator.hardwareConcurrency >= 8) score += 1;
                else if (navigator.hardwareConcurrency <= 2) score -= 1;
            }
            
            // Check memory if available
            if (navigator.deviceMemory) {
                if (navigator.deviceMemory >= 8) score += 0.5;
                else if (navigator.deviceMemory <= 2) score -= 0.5;
            }
            
            // Device detection
            if (/Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent)) {
                score -= 1;
            }
            
            // Check for high-end GPU indicators
            try {
                const ext = gl.getExtension('WEBGL_debug_renderer_info');
                if (ext) {
                    const renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL).toLowerCase();
                    
                    // Boost score for high-end GPUs
                    if (renderer.includes('nvidia') || 
                        renderer.includes('geforce') || 
                        renderer.includes('radeon') ||
                        renderer.includes('adreno') && !renderer.includes('adreno 5') ||
                        renderer.includes('apple m') || 
                        renderer.includes('apple a')) {
                        score += 0.5;
                    }
                }
            } catch (e) {
                // Ignore errors from this experimental feature
            }
            
            // Check frame rate after a short warm-up
            // This is optional and would need to be implemented as a callback
            // after a few seconds of gameplay
            
            // Clamp score between 1-5
            return Math.max(1, Math.min(5, Math.round(score)));
        }

        // Update all chunk fade transitions
        function updateChunkFades(delta) {
            Object.values(terrain).forEach(chunk => {
                if (!chunk.userData) return;
                
                // Handle fade in
                if (chunk.userData.fadeState === 'in' && chunk.userData.fadeProgress < 1) {
                    chunk.userData.fadeProgress += chunk.userData.fadeSpeed;
                    
                    if (chunk.userData.fadeProgress >= 1) {
                        chunk.userData.fadeProgress = 1;
                        chunk.userData.fadeState = 'visible';
                        chunk.userData.fullyLoaded = true;
                        
                        // Fix materials after fade completes
                        chunk.traverse(object => {
                            if (object.material && object.material.transparent) {
                                object.material.opacity = 1;
                                
                                // Only turn off transparency if the material should be fully opaque
                                if (object.material.type !== 'MeshLambertMaterial' || 
                                    !object.material._originalOpacity || 
                                    object.material._originalOpacity >= 1) {
                                    object.material.transparent = false;
                                    object.material.needsUpdate = true;
                                }
                            }
                        });
                    } else {
                        // Update opacity during fade
                        const opacity = chunk.userData.fadeProgress;
                        chunk.traverse(object => {
                            if (object.material) {
                                if (!object.material.transparent) {
                                    object.material.transparent = true;
                                    // Store original opacity if it exists
                                    if (typeof object.material.opacity !== 'undefined') {
                                        object.material._originalOpacity = object.material.opacity;
                                    }
                                }
                                object.material.opacity = opacity * (object.material._originalOpacity || 1);
                                object.material.needsUpdate = true;
                            }
                        });
                    }
                }
                
                // Handle fade out
                else if (chunk.userData.fadeState === 'out' && chunk.userData.fadeProgress > 0) {
                    chunk.userData.fadeProgress -= chunk.userData.fadeSpeed * 2; // Faster fade out
                    
                    if (chunk.userData.fadeProgress <= 0) {
                        chunk.userData.fadeProgress = 0;
                        
                        // Remove the chunk when fade out is complete
                        disposeChunk(chunk);
                        scene.remove(chunk);
                        
                        // Find and remove from terrain object
                        Object.keys(terrain).forEach(key => {
                            if (terrain[key] === chunk) {
                                delete terrain[key];
                            }
                        });
                    } else {
                        // Update opacity during fade
                        const opacity = chunk.userData.fadeProgress;
                        chunk.traverse(object => {
                            if (object.material) {
                                if (!object.material.transparent) {
                                    object.material.transparent = true;
                                }
                                object.material.opacity = opacity * (object.material._originalOpacity || 1);
                                object.material.needsUpdate = true;
                            }
                        });
                    }
                }
            });
        }

        // Process the next chunk in the loading queue
        function processChunkQueue() {
            // If already processing or queue is empty, exit
            if (processingChunk || chunkLoadingQueue.length === 0) return;
            
            // Sort queue by priority and then by distance to player
            chunkLoadingQueue.sort((a, b) => {
                // Primary sort by priority (higher priority first)
                if (a.priority !== b.priority) {
                    return b.priority - a.priority;
                }
                
                // Secondary sort by distance to player (closer first)
                const playerChunkX = Math.floor(player.position.x / chunkSize);
                const playerChunkZ = Math.floor(player.position.z / chunkSize);
                
                const distA = Math.max(Math.abs(a.x - playerChunkX), Math.abs(a.z - playerChunkZ));
                const distB = Math.max(Math.abs(b.x - playerChunkX), Math.abs(b.z - playerChunkZ));
                
                return distA - distB;
            });
            
            // Get the highest priority chunk
            const nextChunk = chunkLoadingQueue.shift();
            processingChunk = true;
            
            // Use setTimeout to spread the load across frames
            setTimeout(() => {
                try {
                    // Check if chunk still needs to be generated
                    const chunkKey = `${nextChunk.x},${nextChunk.z}`;
                    
                    // Make sure this chunk doesn't already exist in active terrain
                    if (!terrain[chunkKey]) {
                        // Generate the chunk
                        generateChunk(nextChunk.x, nextChunk.z, nextChunk.priority, nextChunk.fadeIn);
                    }
                } catch (error) {
                    console.error("Error processing chunk:", error);
                } finally {
                    processingChunk = false;
                    
                    // Continue processing the queue
                    if (chunkLoadingQueue.length > 0) {
                        processChunkQueue();
                    }
                }
            }, 0);
        }

        // Calculate player movement direction for predictive loading
        function updatePlayerDirection() {
            const now = performance.now();
            
            // Only update direction periodically to avoid jitter
            if (now - lastDirectionUpdateTime < 500) return;
            
            // Calculate movement direction
            if (previousPlayerPosition.distanceToSquared(player.position) > 0.01) {
                playerDirection.subVectors(player.position, previousPlayerPosition).normalize();
                previousPlayerPosition.copy(player.position);
                lastDirectionUpdateTime = now;
            }
        }

        // Apply stored player modifications to a cached chunk
        function applyChunkModifications(chunkKey, chunkGroup) {
            const mods = chunkModifications[chunkKey];
            if (!mods) return;
            
            console.log(`Applying ${Object.keys(mods).length} modifications to chunk ${chunkKey}`);
            
            // Apply each modification to the chunk
            for (const [posKey, mod] of Object.entries(mods)) {
                const [x, y, z] = posKey.split(',').map(Number);
                
                if (mod.action === 'add') {
                    // Add a block
                    if (!chunkGroup.blockPositions[posKey]) {
                        chunkGroup.blockPositions[posKey] = {
                            type: mod.blockType,
                            index: Object.keys(chunkGroup.blockPositions).length
                        };
                        
                        // Create the actual mesh
                        const material = blockMaterials[mod.blockType] || blockMaterials.stone;
                        const mesh = new THREE.Mesh(blockGeometry, material.clone());
                        mesh.position.set(x, y, z);
                        chunkGroup.add(mesh);
                    }
                } else if (mod.action === 'remove') {
                    // Remove a block
                    delete chunkGroup.blockPositions[posKey];
                    
                    // Find and remove any matching mesh
                    for (let i = chunkGroup.children.length - 1; i >= 0; i--) {
                        const blockMesh = chunkGroup.children[i];
                        if (Math.abs(blockMesh.position.x - x) < 0.1 && 
                            Math.abs(blockMesh.position.y - y) < 0.1 && 
                            Math.abs(blockMesh.position.z - z) < 0.1) {
                            chunkGroup.remove(blockMesh);
                            break;
                        }
                    }
                }
            }
        }
    </script>
</body>
</html>


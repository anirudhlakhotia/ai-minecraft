<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft-Inspired 3D World</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
        }

        #ui button {
            background: rgba(255, 255, 255, 0.7);
            border: 2px solid #555;
            border-radius: 5px;
            padding: 8px 15px;
            margin-right: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        #ui button:hover {
            background: rgba(255, 255, 255, 0.9);
        }

        #ui button.active {
            background: rgba(100, 255, 100, 0.7);
        }

        #blockSelector {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            color: white;
        }

        #blockSelector div {
            margin: 10px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            padding: 5px;
            border-radius: 5px;
        }

        #blockSelector div:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #blockSelector div.selected {
            background: rgba(255, 255, 255, 0.3);
        }

        .block-preview {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            border: 1px solid #888;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }

        #crosshair::before, #crosshair::after {
            content: "";
            position: absolute;
            background: white;
        }

        #crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #crosshair::after {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #instructions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 1000;
        }

        #instructions button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            margin-top: 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
        }

        #timeDisplay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }

        /* Crafting system styles */
        #craftingUI {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 400px;
            background: rgba(50, 50, 50, 0.9);
            border: 3px solid #555;
            border-radius: 8px;
            padding: 20px;
            display: none;
            z-index: 2000;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #craftingGrid {
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 80px);
            gap: 5px;
            margin: 0 auto 20px;
            width: 250px;
        }

        .craftingSlot {
            width: 80px;
            height: 80px;
            background: rgba(80, 80, 80, 0.7);
            border: 2px solid #777;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }

        .craftingSlot:hover {
            background: rgba(100, 100, 100, 0.7);
        }

        .craftingSlot.filled {
            background: rgba(120, 120, 120, 0.7);
        }

        .resultSlot {
            width: 100px;
            height: 100px;
            background: rgba(60, 110, 60, 0.7);
            border: 2px solid #5a5;
            margin: 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #inventoryGrid {
            display: grid;
            grid-template-columns: repeat(5, 60px);
            gap: 5px;
            margin-top: 20px;
        }

        .inventorySlot {
            width: 60px;
            height: 60px;
            background: rgba(80, 80, 80, 0.7);
            border: 2px solid #777;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }

        .inventorySlot:hover {
            background: rgba(100, 100, 100, 0.7);
        }

        .slotItem {
            width: 40px;
            height: 40px;
            border-radius: 5px;
        }

        .slotQuantity {
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
        }

        #craftingButtons {
            display: flex;
            justify-content: center;
            margin-top: 15px;
        }

        #craftingButtons button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
        }

        #craftingButtons button:hover {
            background: #3e8e41;
        }

        #craftingButtons button:disabled {
            background: #888;
            cursor: not-allowed;
        }

        #inventoryDisplay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .invItem {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .invIcon {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>Minecraft-Inspired 3D World</h1>
        <p>Use WASD to move, SPACE to jump, MOUSE to look around</p>
        <p>LEFT CLICK to remove blocks, RIGHT CLICK to place blocks</p>
        <p>Select different block types from the menu on the right</p>
        <p>Choose biomes using the buttons at the bottom</p>
        <button id="startButton">Start Game</button>
    </div>

    <div id="crosshair"></div>

    <div id="timeDisplay">Time: Day</div>

    <div id="ui">
        <button class="biome-btn active" data-biome="forest">Forest</button>
        <button class="biome-btn" data-biome="desert">Desert</button>
        <button class="biome-btn" data-biome="mountains">Mountains</button>
        <button class="biome-btn" data-biome="plains">Plains</button>
    </div>

    <div id="blockSelector">
        <h3>Block Types</h3>
        <div class="block-type selected" data-type="grass">
            <div class="block-preview" style="background-color: #5D9E47;"></div>
            <span>Grass</span>
        </div>
        <div class="block-type" data-type="dirt">
            <div class="block-preview" style="background-color: #8B5A2B;"></div>
            <span>Dirt</span>
        </div>
        <div class="block-type" data-type="stone">
            <div class="block-preview" style="background-color: #888888;"></div>
            <span>Stone</span>
        </div>
        <div class="block-type" data-type="sand">
            <div class="block-preview" style="background-color: #E2D9A2;"></div>
            <span>Sand</span>
        </div>
        <div class="block-type" data-type="wood">
            <div class="block-preview" style="background-color: #8B4513;"></div>
            <span>Wood</span>
        </div>
    </div>

    <!-- Crafting Interface -->
    <div id="craftingUI">
        <h2 style="text-align: center; margin-top: 0;">Crafting</h2>
        
        <div id="craftingGrid">
            <!-- 3x3 crafting grid, will be populated by JavaScript -->
        </div>
        
        <div class="resultSlot" id="resultSlot">
            <!-- Result will appear here -->
        </div>
        
        <div id="craftingButtons">
            <button id="craftBtn" disabled>Craft</button>
            <button id="clearBtn">Clear</button>
            <button id="closeCraftingBtn">Close</button>
        </div>
        
        <h3 style="margin-top: 20px;">Inventory</h3>
        <div id="inventoryGrid">
            <!-- Inventory slots will be populated by JavaScript -->
        </div>
    </div>

    <!-- Simple Inventory Display (always visible) -->
    <div id="inventoryDisplay">
        <!-- Will be populated with current inventory -->
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let terrain = {}, worldSize = 16, chunkSize = 16, viewDistance = 2;
        let player = { 
            position: new THREE.Vector3(0, 100, 0), // Start at a safe height
            velocity: new THREE.Vector3(0, 0, 0),
            lastChunkX: 0,
            lastChunkZ: 0,
            spawnHeight: 100, // Safe initial height
            isSpawning: true, // Flag to indicate initial spawn
            spawned: false // Flag to track if player has safely spawned
        };
        let keyboard = {};
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let clock = new THREE.Clock();
        let blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        let selectedBlockType = 'grass';
        let currentBiome = 'forest';
        let dayNightCycle = { time: 0, duration: 300, isDay: true }; // 5 minutes per cycle
        let isGameStarted = false;
        let simplex = new SimplexNoise();
        
        // Audio elements
        let ambientSounds = {
            forest: new Audio('https://freesound.org/data/previews/462/462087_8386274-lq.mp3'),
            desert: new Audio('https://freesound.org/data/previews/361/361259_4284968-lq.mp3'),
            mountains: new Audio('https://freesound.org/data/previews/352/352149_43962-lq.mp3'),
            plains: new Audio('https://freesound.org/data/previews/211/211545_3267529-lq.mp3')
        };
        
        // Block textures and materials with improved colors for realism and contrast
        const blockMaterials = {
            grass: new THREE.MeshLambertMaterial({ color: 0x3A9D23 }), // Vibrant natural green
            dirt: new THREE.MeshLambertMaterial({ color: 0x59472B }), // Rich earth brown
            stone: new THREE.MeshLambertMaterial({ color: 0x666666 }), // Medium gray
            sand: new THREE.MeshLambertMaterial({ color: 0xDBC681 }), // Base desert sand
            sand_light: new THREE.MeshLambertMaterial({ color: 0xE8D9A0 }), // Light sand for dune tops
            sand_red: new THREE.MeshLambertMaterial({ color: 0xC2A477 }), // Reddish sand
            sand_gold: new THREE.MeshLambertMaterial({ color: 0xD4B16A }), // Golden sand
            sand_dark: new THREE.MeshLambertMaterial({ color: 0xB49B6C }), // Darker sand for shadowed areas
            wood: new THREE.MeshLambertMaterial({ color: 0x52341D }), // Dark brown wood
            snow: new THREE.MeshLambertMaterial({ color: 0xF5F5F5 }), // Bright white snow
            water: new THREE.MeshLambertMaterial({ color: 0x1A45A5, transparent: true, opacity: 0.8 }), // Deep blue water
            cactus: new THREE.MeshLambertMaterial({ color: 0x2D742F }) // Dark green cactus
        };
        
        // Crafting system variables
        let playerInventory = {
            grass: 0,
            dirt: 0,
            stone: 0,
            sand: 0,
            wood: 0,
            stick: 0,
            wooden_pickaxe: 0,
            stone_pickaxe: 0,
            wooden_axe: 0,
            stone_axe: 0,
            crafting_table: 0
        };
        
        let craftingGrid = [
            [null, null, null],
            [null, null, null],
            [null, null, null]
        ];
        
        let isCraftingOpen = false;
        let currentRecipeResult = null;
        let selectedInventorySlot = null;
        
        // Recipe definitions
        const recipes = [
            {
                id: "stick",
                pattern: [
                    [null, null, null],
                    [null, "wood", null],
                    [null, "wood", null]
                ],
                result: { item: "stick", quantity: 4 }
            },
            {
                id: "wooden_pickaxe",
                pattern: [
                    ["wood", "wood", "wood"],
                    [null, "stick", null],
                    [null, "stick", null]
                ],
                result: { item: "wooden_pickaxe", quantity: 1 }
            },
            {
                id: "wooden_axe",
                pattern: [
                    ["wood", "wood", null],
                    ["wood", "stick", null],
                    [null, "stick", null]
                ],
                result: { item: "wooden_axe", quantity: 1 }
            },
            {
                id: "stone_pickaxe",
                pattern: [
                    ["stone", "stone", "stone"],
                    [null, "stick", null],
                    [null, "stick", null]
                ],
                result: { item: "stone_pickaxe", quantity: 1 }
            },
            {
                id: "stone_axe",
                pattern: [
                    ["stone", "stone", null],
                    ["stone", "stick", null],
                    [null, "stick", null]
                ],
                result: { item: "stone_axe", quantity: 1 }
            },
            {
                id: "crafting_table",
                pattern: [
                    ["wood", "wood", null],
                    ["wood", "wood", null],
                    [null, null, null]
                ],
                result: { item: "crafting_table", quantity: 1 }
            }
        ];
        
        // Item display properties (colors, names, etc.)
        const itemProperties = {
            grass: { color: "#3A9D23", name: "Grass Block" },
            dirt: { color: "#59472B", name: "Dirt" },
            stone: { color: "#666666", name: "Stone" },
            sand: { color: "#DBC681", name: "Sand" },
            water: { color: "#1E90FF", name: "Water" },
            wood: { color: "#52341D", name: "Wood" },
            stick: { 
                color: "#8B5A2B", 
                name: "Stick",
                render: function(element) {
                    element.style.backgroundColor = "#8B5A2B";
                    element.style.width = "15px";
                    element.style.height = "35px";
                    element.style.margin = "auto";
                }
            },
            wooden_pickaxe: { 
                color: "#8B4513", 
                name: "Wooden Pickaxe",
                render: function(element) {
                    // Create pickaxe head
                    const head = document.createElement('div');
                    head.style.width = "30px";
                    head.style.height = "10px";
                    head.style.backgroundColor = "#8B4513";
                    head.style.position = "absolute";
                    head.style.top = "5px";
                    head.style.left = "50%";
                    head.style.transform = "translateX(-50%)";
                    
                    // Create handle
                    const handle = document.createElement('div');
                    handle.style.width = "6px";
                    handle.style.height = "25px";
                    handle.style.backgroundColor = "#8B5A2B";
                    handle.style.position = "absolute";
                    handle.style.top = "15px";
                    handle.style.left = "50%";
                    handle.style.transform = "translateX(-50%)";
                    
                    element.innerHTML = '';
                    element.appendChild(head);
                    element.appendChild(handle);
                    element.style.position = "relative";
                }
            },
            stone_pickaxe: { 
                color: "#808080", 
                name: "Stone Pickaxe",
                render: function(element) {
                    // Create pickaxe head
                    const head = document.createElement('div');
                    head.style.width = "30px";
                    head.style.height = "10px";
                    head.style.backgroundColor = "#808080";
                    head.style.position = "absolute";
                    head.style.top = "5px";
                    head.style.left = "50%";
                    head.style.transform = "translateX(-50%)";
                    
                    // Create handle
                    const handle = document.createElement('div');
                    handle.style.width = "6px";
                    handle.style.height = "25px";
                    handle.style.backgroundColor = "#8B5A2B";
                    handle.style.position = "absolute";
                    handle.style.top = "15px";
                    handle.style.left = "50%";
                    handle.style.transform = "translateX(-50%)";
                    
                    element.innerHTML = '';
                    element.appendChild(head);
                    element.appendChild(handle);
                    element.style.position = "relative";
                }
            },
            wooden_axe: { 
                color: "#8B4513", 
                name: "Wooden Axe",
                render: function(element) {
                    // Create axe head
                    const head = document.createElement('div');
                    head.style.width = "20px";
                    head.style.height = "20px";
                    head.style.backgroundColor = "#8B4513";
                    head.style.position = "absolute";
                    head.style.top = "2px";
                    head.style.left = "60%";
                    head.style.clipPath = "polygon(0% 50%, 50% 0%, 100% 50%, 50% 100%)";
                    
                    // Create handle
                    const handle = document.createElement('div');
                    handle.style.width = "6px";
                    handle.style.height = "30px";
                    handle.style.backgroundColor = "#8B5A2B";
                    handle.style.position = "absolute";
                    handle.style.top = "10px";
                    handle.style.left = "40%";
                    handle.style.transform = "rotate(45deg)";
                    
                    element.innerHTML = '';
                    element.appendChild(handle);
                    element.appendChild(head);
                    element.style.position = "relative";
                }
            },
            stone_axe: { 
                color: "#808080", 
                name: "Stone Axe",
                render: function(element) {
                    // Create axe head
                    const head = document.createElement('div');
                    head.style.width = "20px";
                    head.style.height = "20px";
                    head.style.backgroundColor = "#808080";
                    head.style.position = "absolute";
                    head.style.top = "2px";
                    head.style.left = "60%";
                    head.style.clipPath = "polygon(0% 50%, 50% 0%, 100% 50%, 50% 100%)";
                    
                    // Create handle
                    const handle = document.createElement('div');
                    handle.style.width = "6px";
                    handle.style.height = "30px";
                    handle.style.backgroundColor = "#8B5A2B";
                    handle.style.position = "absolute";
                    handle.style.top = "10px";
                    handle.style.left = "40%";
                    handle.style.transform = "rotate(45deg)";
                    
                    element.innerHTML = '';
                    element.appendChild(handle);
                    element.appendChild(head);
                    element.style.position = "relative";
                }
            },
            crafting_table: { 
                color: "#7D5A1A", 
                name: "Crafting Table",
                render: function(element) {
                    // Create grid pattern
                    element.style.backgroundImage = "linear-gradient(#8B5A2B 1px, transparent 1px), linear-gradient(90deg, #8B5A2B 1px, transparent 1px)";
                    element.style.backgroundSize = "10px 10px";
                    element.style.backgroundColor = "#7D5A1A";
                }
            }
        };
        
        // Global variables section - add this variable
        let highlightBox;
        
        // Find a safe spawn point in the current biome
        function findSafeSpawnPoint() {
            console.log("Finding safe spawn point in biome:", currentBiome);
            
            // Define safe spawn areas for each biome
            let spawnAreaX = 0; 
            let spawnAreaZ = 0;
            
            switch(currentBiome) {
                case 'desert':
                    spawnAreaX = 16;
                    spawnAreaZ = 16;
                    break;
                case 'mountains':
                    // For mountains, spawn in a lower-elevation valley area
                    spawnAreaX = 24;
                    spawnAreaZ = 24;
                    break;
                case 'plains':
                    spawnAreaX = 8;
                    spawnAreaZ = 8;
                    break;
                case 'forest':
                default:
                    spawnAreaX = 12;
                    spawnAreaZ = 12;
                    break;
            }
            
            // For mountains, find a lower area to spawn
            if (currentBiome === 'mountains') {
                // Scan several positions to find a good valley to spawn in
                let bestHeight = 999;
                let bestX = spawnAreaX;
                let bestZ = spawnAreaZ;
                
                // Try different spots within a region
                for (let xOffset = -8; xOffset <= 8; xOffset += 2) {
                    for (let zOffset = -8; zOffset <= 8; zOffset += 2) {
                        const testX = spawnAreaX + xOffset;
                        const testZ = spawnAreaZ + zOffset;
                        const height = getTerrainHeight(testX, testZ, currentBiome);
                        
                        // Look for a lower spot to avoid spawning on peaks
                        if (height < bestHeight) {
                            bestHeight = height;
                            bestX = testX;
                            bestZ = testZ;
                        }
                    }
                }
                
                spawnAreaX = bestX;
                spawnAreaZ = bestZ;
            }
            
            // Find surface height at spawn location
            const height = getTerrainHeight(spawnAreaX, spawnAreaZ, currentBiome);
            
            // Set player position to safe height above terrain
            player.position.set(spawnAreaX, height + 5, spawnAreaZ);
            player.spawnHeight = height + 5;
            
            console.log(`Safe spawn point found at (${spawnAreaX}, ${height + 5}, ${spawnAreaZ})`);
            
            // Update last chunk position to trigger terrain generation
            player.lastChunkX = Math.floor(player.position.x / chunkSize);
            player.lastChunkZ = Math.floor(player.position.z / chunkSize);
            
            // Update camera position
            if (camera) {
                camera.position.copy(player.position);
                camera.position.y += 1.7; // Eye height
            }
            
            return true;
        }
        
        // Get terrain height based on biome with improved realism
        function getTerrainHeight(x, z, biome) {
            // Use deterministic noise with fixed seed
            // We'll use a different frequency for each biome but keep coordinates consistent
            const scale1 = biome === 'mountains' ? 0.02 : 0.01;
            const scale2 = biome === 'plains' ? 0.03 : 0.05;
            const scale3 = 0.002;
            
            // Make sure to use absolute coordinates that don't depend on player position
            // This prevents terrain from "moving"
            switch (biome) {
                case 'desert':
                    return 7 + Math.floor(8 * (
                        0.8 * simplex.noise2D(x * 0.01, z * 0.01) +
                        0.2 * simplex.noise2D(x * 0.05, z * 0.05) * 
                        Math.pow(Math.abs(simplex.noise2D(x * 0.002, z * 0.002)), 0.7)
                    ));
                    
                case 'mountains':
                    // More dramatic mountain terrain with higher peaks and deeper valleys
                    const baseElevation = 20; // Higher base elevation for mountains
                    const ridgeNoise = Math.pow(Math.abs(simplex.noise2D(x * 0.005, z * 0.005)), 0.8); // Ridge formations
                    const detailNoise = 
                        0.6 * simplex.noise2D(x * 0.03, z * 0.03) + 
                        0.4 * simplex.noise2D(x * 0.08, z * 0.08); // Small details
                    const peakiness = Math.pow(Math.abs(simplex.noise2D(x * 0.001, z * 0.001)), 0.3); // Controls how sharp peaks are
                    
                    const mountainHeight = baseElevation + Math.floor(60 * ridgeNoise * peakiness * (0.8 + 0.4 * detailNoise));
                    return mountainHeight;
                    
                case 'plains':
                    // Check for river path using noise
                    const riverNoise = simplex.noise2D(x * 0.02, z * 0.02);
                    const riverChannel = Math.abs(riverNoise);
                    
                    // River path when riverChannel is small
                    if (riverChannel < 0.05) {
                        return 8; // River level
                    }
                    
                    // Riverbank when close to the river
                    if (riverChannel < 0.12) {
                        return 9 + Math.floor(riverChannel * 20); // Sloping riverbank
                    }
                    
                    // Normal plains with gentle rolling hills
                    return 11 + Math.floor(3 * (
                        0.8 * simplex.noise2D(x * 0.01, z * 0.01) +
                        0.2 * simplex.noise2D(x * 0.04, z * 0.04)
                    ));
                    
                case 'forest':
                default:
                    return 12 + Math.floor(8 * (
                        0.6 * simplex.noise2D(x * 0.01, z * 0.01) +
                        0.4 * simplex.noise2D(x * 0.05, z * 0.05)
                    ));
            }
        }
        
        // Function to create a block without outlines
        function createBlock(x, y, z, type, parent) {
            // Create the main block
            const material = blockMaterials[type] || blockMaterials.stone;
            const mesh = new THREE.Mesh(blockGeometry, material);
            mesh.position.set(x, y, z);
            
            // Add the block to the parent
            parent.add(mesh);
            return mesh;
        }
        
        // Create a tree with better color differentiation
        function createTree(x, y, z, parent) {
            // Tree trunk
            const trunkHeight = Math.floor(4 + (Math.abs(x * z) % 3)); // Deterministic height
            for (let i = 0; i < trunkHeight; i++) {
                createBlock(x, y + i, z, 'wood', parent);
                const posKey = `${x},${y + i},${z}`;
                parent.blockPositions[posKey] = { type: 'wood' };
            }
            
            // Tree leaves (more natural shape)
            const leafRadius = 2;
            const leafHeight = 3;
            for (let ly = 0; ly <= leafHeight; ly++) {
                // Make a wider canopy near the middle, narrower at top
                const levelRadius = ly === 0 || ly === leafHeight ? 1 : leafRadius;
                
                for (let lx = -levelRadius; lx <= levelRadius; lx++) {
                    for (let lz = -levelRadius; lz <= levelRadius; lz++) {
                        // Skip corners to make it more rounded
                        if (Math.abs(lx) === leafRadius && Math.abs(lz) === leafRadius) {
                            continue;
                        }
                        
                        // Check if leaf should be placed (deterministic randomness)
                        const leafSeed = (x + lx) * 1000 + (z + lz) * 10 + ly;
                        if (seededRandom(leafSeed)() > 0.8 && Math.abs(lx) === leafRadius && Math.abs(lz) === leafRadius) {
                            continue;
                        }
                        
                        createBlock(x + lx, y + trunkHeight + ly - 1, z + lz, 'grass', parent);
                        const posKey = `${x + lx},${y + trunkHeight + ly - 1},${z + lz}`;
                        parent.blockPositions[posKey] = { type: 'grass' };
                    }
                }
            }
        }
        
        // Seeded random function for deterministic generation
        function seededRandom(seed) {
            return function() {
                const x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            };
        }
        
        // Generate a single terrain chunk with optimized and fixed performance
        function generateChunk(chunkX, chunkZ) {
            const chunkKey = `${chunkX},${chunkZ}`;
            if (terrain[chunkKey]) return;
            
            const chunkGroup = new THREE.Group();
            chunkGroup.blockPositions = {};
            
            // Distance from player for LOD
            const playerChunkX = Math.floor(player.position.x / chunkSize);
            const playerChunkZ = Math.floor(player.position.z / chunkSize);
            const distanceFromPlayer = Math.max(Math.abs(chunkX - playerChunkX), Math.abs(chunkZ - playerChunkZ));
            
            // Generate blocks in chunk based on deterministic noise
            for (let x = 0; x < chunkSize; x++) {
                for (let z = 0; z < chunkSize; z++) {
                    const worldX = chunkX * chunkSize + x;
                    const worldZ = chunkZ * chunkSize + z;
                    
                    // Get terrain height - this needs to be consistent regardless of player position
                    const height = getTerrainHeight(worldX, worldZ, currentBiome);
                    
                    // Determine how deep to render based on distance (LOD)
                    const renderDepth = distanceFromPlayer === 0 ? 15 : 5;
                    
                    // Generate blocks from bedrock to surface
                    for (let y = 0; y < height; y++) {
                        // Determine block type based on height and biome with more natural distribution
                        let blockType;
                        
                        if (y === height - 1) {
                            // Surface block - more realistic based on biome and elevation
                            switch (currentBiome) {
                                case 'desert':
                                    // Determine sand type based on noise patterns
                                    const sandNoise = simplex.noise2D(worldX * 0.05, worldZ * 0.05);
                                    const elevationFactor = simplex.noise2D(worldX * 0.01, worldZ * 0.01);
                                    
                                    // Create different sand types based on elevation and patterns
                                    if (sandNoise > 0.6) {
                                        blockType = 'sand_light'; // Light sand on dune tops
                                    } else if (sandNoise < -0.6) {
                                        blockType = 'sand_dark'; // Darker sand in lower areas
                                    } else if (elevationFactor > 0.4 && height > 10) {
                                        blockType = 'sand_red'; // Reddish sand on higher areas
                                    } else if (elevationFactor < -0.4) {
                                        blockType = 'sand_gold'; // Golden sand in specific patterns
                                    } else {
                                        blockType = 'sand'; // Base sand elsewhere
                                    }
                                    break;
                                case 'mountains':
                                    // Snow caps on mountain peaks, stone on cliffs, dirt/grass on lower areas
                                    if (y > 55) {
                                        blockType = 'snow'; // Snow-capped peaks
                                    } else if (y > 45) {
                                        // Transition zone - mix of snow and stone
                                        const snowThreshold = (y - 45) / 10; // 0 at y=45, 1 at y=55
                                        blockType = (Math.random() < snowThreshold) ? 'snow' : 'stone';
                                    } else if (y > 35) {
                                        blockType = 'stone'; // Rocky mountain sides
                                    } else if (y > 28) {
                                        // Transition zone - mix of stone and dirt
                                        const stoneThreshold = (y - 28) / 7; // 0 at y=28, 1 at y=35
                                        blockType = (Math.random() < stoneThreshold) ? 'stone' : 'dirt';
                                    } else {
                                        blockType = (y > 25) ? 'dirt' : 'grass'; // Lower slopes and valleys
                                    }
                                    break;
                                case 'plains':
                                    // Check for river or pond
                                    const riverNoise = Math.abs(simplex.noise2D(worldX * 0.02, worldZ * 0.02));
                                    if (riverNoise < 0.05 && y <= 8) {
                                        blockType = 'water'; // River water
                                    } else if (y === 8 && riverNoise < 0.05) {
                                        blockType = 'sand'; // River bed
                                    } else if (riverNoise < 0.12 && y < 11) {
                                        blockType = 'dirt'; // Riverbank
                                    } else {
                                        // Normal grass plains with some variety
                                        const varietyNoise = simplex.noise2D(worldX * 0.1, worldZ * 0.1);
                                        if (varietyNoise > 0.7) {
                                            blockType = 'dirt'; // Occasional dirt patches
                                        } else {
                                            blockType = 'grass'; // Mostly grass
                                        }
                                    }
                                    break;
                                case 'forest':
                                    blockType = 'grass';
                                    // Add occasional dirt patches
                                    if (Math.random() < 0.05) blockType = 'dirt';
                                    break;
                            }
                        } else if (y > height - 4) {
                            // Subsurface layers
                            if (currentBiome === 'desert') {
                                // Add some variation to subsurface sand too
                                const depthNoise = simplex.noise2D(worldX * 0.03, worldZ * 0.03);
                                
                                if (depthNoise > 0.7) {
                                    blockType = 'sand_gold';
                                } else if (depthNoise < -0.7) {
                                    blockType = 'sand_red';
                                } else {
                                    blockType = 'sand';
                                }
                            } else if (currentBiome === 'mountains') {
                                if (y > 50) {
                                    blockType = 'snow'; // Snow layers under surface
                                } else if (y > 35) {
                                    blockType = 'stone'; // Stone layers in mountains
                                } else {
                                    blockType = 'dirt'; // Dirt layers at lower elevations
                                }
                            } else if (currentBiome === 'plains' && y <= 8) {
                                // River bottom is sandy
                                const riverNoise = Math.abs(simplex.noise2D(worldX * 0.02, worldZ * 0.02));
                                if (riverNoise < 0.05) {
                                    blockType = 'sand';
                                } else {
                                    blockType = 'dirt';
                                }
                            } else {
                                blockType = 'dirt';
                            }
                        } else {
                            // Deep layers
                            blockType = 'stone';
                        }
                        
                        // Only create blocks near the surface to improve performance
                        if (y > height - renderDepth) {
                            createBlock(worldX, y, worldZ, blockType, chunkGroup);
                        }
                        
                        // Always store position for collision detection
                        const posKey = `${worldX},${y},${worldZ}`;
                        chunkGroup.blockPositions[posKey] = { type: blockType };
                    }
                    
                    // Add biome-specific features with deterministic placement
                    // Use a deterministic seed for features so they don't change when we regenerate chunks
                    const featureSeed = worldX * 10000 + worldZ;
                    const featureRandom = seededRandom(featureSeed);
                    
                    if (distanceFromPlayer <= 1) {
                        // FOREST FEATURES
                        if (currentBiome === 'forest' && featureRandom() < 0.03 && height > 5) {
                            createTree(worldX, height, worldZ, chunkGroup);
                        }
                        
                        // DESERT FEATURES
                        if (currentBiome === 'desert') {
                            // Add sand dune transitions
                            const dunePattern = simplex.noise2D(worldX * 0.03, worldZ * 0.03);
                            if (dunePattern > 0.7 && height > 9) {
                                // Create dune crest with lighter sand extending upward
                                createBlock(worldX, height, worldZ, 'sand_light', chunkGroup);
                                const duneKey = `${worldX},${height},${worldZ}`;
                                chunkGroup.blockPositions[duneKey] = { type: 'sand_light' };
                            }
                            
                            // Add occasional red sand patches
                            if (featureRandom() < 0.05 && dunePattern < -0.5) {
                                // Create a small patch of red sand
                                for (let dx = -1; dx <= 1; dx++) {
                                    for (let dz = -1; dz <= 1; dz++) {
                                        const distance = Math.sqrt(dx*dx + dz*dz);
                                        if (distance <= 1.5) {
                                            const redSandHeight = getTerrainHeight(worldX + dx, worldZ + dz, currentBiome);
                                            createBlock(worldX + dx, redSandHeight, worldZ + dz, 'sand_red', chunkGroup);
                                            const redSandKey = `${worldX + dx},${redSandHeight},${worldZ + dz}`;
                                            chunkGroup.blockPositions[redSandKey] = { type: 'sand_red' };
                                        }
                                    }
                                }
                            }
                        }
                        
                        // MOUNTAIN FEATURES
                        if (currentBiome === 'mountains') {
                            // Add random boulders in mountain biome
                            if (featureRandom() < 0.04 && height < 50 && height > 25) {
                                // Large and small boulders to add character
                                const boulderSize = Math.floor(1 + featureRandom() * 2);
                                for (let bx = 0; bx < boulderSize; bx++) {
                                    for (let by = 0; by < boulderSize; by++) {
                                        for (let bz = 0; bz < boulderSize; bz++) {
                                            // Create roughly spherical boulder
                                            const distance = Math.sqrt(
                                                Math.pow(bx - boulderSize/2, 2) + 
                                                Math.pow(by - boulderSize/2, 2) + 
                                                Math.pow(bz - boulderSize/2, 2)
                                            );
                                            if (distance <= boulderSize/2) {
                                                createBlock(worldX + bx, height + by, worldZ + bz, 'stone', chunkGroup);
                                                const posKey = `${worldX + bx},${height + by},${worldZ + bz}`;
                                                chunkGroup.blockPositions[posKey] = { type: 'stone' };
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Add small alpine plants in mountain biome at middle elevations
                            if (featureRandom() < 0.1 && height < 45 && height > 30) {
                                createBlock(worldX, height, worldZ, 'grass', chunkGroup);
                                const posKey = `${worldX},${height},${worldZ}`;
                                chunkGroup.blockPositions[posKey] = { type: 'grass' };
                            }
                        }
                        
                        // PLAINS FEATURES
                        if (currentBiome === 'plains') {
                            // Check if we're not in or very near the river
                            const riverNoise = Math.abs(simplex.noise2D(worldX * 0.02, worldZ * 0.02));
                            
                            if (riverNoise >= 0.12) {
                                // Add scattered trees (much less dense than forest)
                                if (featureRandom() < 0.005 && height > 10) {
                                    createTree(worldX, height, worldZ, chunkGroup);
                                }
                                
                                // Add tall grass and flowers
                                if (featureRandom() < 0.2 && height > 10) {
                                    // Choose between grass and flowers based on another random
                                    if (featureRandom() < 0.3) {
                                        // Create a flower (just a different colored block for now)
                                        const flowerType = featureRandom() < 0.5 ? 'yellow_flower' : 'red_flower';
                                        createFlower(worldX, height, worldZ, flowerType, chunkGroup);
                                    } else {
                                        // Create tall grass
                                        createTallGrass(worldX, height, worldZ, chunkGroup);
                                    }
                                }
                                
                                // Add occasional rock formations
                                if (featureRandom() < 0.01 && height > 10) {
                                    // Small rock formation
                                    const rockSize = 1 + Math.floor(featureRandom() * 1.5);
                                    for (let rx = 0; rx < rockSize; rx++) {
                                        for (let ry = 0; ry < rockSize; ry++) {
                                            for (let rz = 0; rz < rockSize; rz++) {
                                                if (featureRandom() < 0.7) { // Makes rocks more irregular
                                                    createBlock(worldX + rx, height + ry, worldZ + rz, 'stone', chunkGroup);
                                                    const posKey = `${worldX + rx},${height + ry},${worldZ + rz}`;
                                                    chunkGroup.blockPositions[posKey] = { type: 'stone' };
                                                }
                                            }
                                        }
                                    }
                                }
                            } else if (riverNoise < 0.06) {
                                // Add occasional water lilies on river
                                if (featureRandom() < 0.05 && height <= 8) {
                                    createWaterLily(worldX, 9, worldZ, chunkGroup);
                                }
                                
                                // Add occasional reeds along riverbank
                                if (riverNoise >= 0.04 && riverNoise < 0.06 && featureRandom() < 0.3) {
                                    createReed(worldX, height + 1, worldZ, chunkGroup);
                                }
                            }
                            
                            // Add ponds away from rivers
                            if (riverNoise > 0.3 && featureRandom() < 0.002) {
                                createPond(worldX, height, worldZ, chunkGroup);
                            }
                        }
                    }
                }
            }
            
            scene.add(chunkGroup);
            terrain[chunkKey] = chunkGroup;
        }
        
        // Create a tall grass decoration
        function createTallGrass(x, y, z, parent) {
            // Create a cross-shaped tall grass using two rotated planes
            const grassBlock = new THREE.Group();
            grassBlock.position.set(x, y, z);
            
            // Use a slightly different green than regular grass blocks
            const grassMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x5DB653, 
                transparent: true,
                opacity: 0.9
            });
            
            // Create a simple box for now - could be enhanced with actual grass models
            const grass = new THREE.Mesh(blockGeometry, grassMaterial);
            grass.scale.set(0.5, 0.5, 0.5);
            grass.position.y += 0.3;
            
            grassBlock.add(grass);
            parent.add(grassBlock);
            
            // Add to block positions for collision
            const posKey = `${x},${y},${z}`;
            parent.blockPositions[posKey] = { type: 'tallgrass', collision: false };
            
            return grassBlock;
        }
        
        // Create a flower
        function createFlower(x, y, z, flowerType, parent) {
            const flowerBlock = new THREE.Group();
            flowerBlock.position.set(x, y, z);
            
            // Different materials for different flower types
            let flowerMaterial;
            if (flowerType === 'red_flower') {
                flowerMaterial = new THREE.MeshLambertMaterial({ color: 0xE05858 });
            } else {
                flowerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFF156 });
            }
            
            // Create a simple small cube for the flower
            const flower = new THREE.Mesh(blockGeometry, flowerMaterial);
            flower.scale.set(0.4, 0.4, 0.4);
            flower.position.y += 0.3;
            
            flowerBlock.add(flower);
            parent.add(flowerBlock);
            
            // Flowers don't block movement
            const posKey = `${x},${y},${z}`;
            parent.blockPositions[posKey] = { type: flowerType, collision: false };
            
            return flowerBlock;
        }
        
        // Create a water lily pad
        function createWaterLily(x, y, z, parent) {
            const lilyGroup = new THREE.Group();
            lilyGroup.position.set(x, y, z);
            
            // Create lily pad with green material
            const lilyMaterial = new THREE.MeshLambertMaterial({ color: 0x2D8653 });
            const lily = new THREE.Mesh(blockGeometry, lilyMaterial);
            lily.scale.set(0.8, 0.1, 0.8);
            
            lilyGroup.add(lily);
            parent.add(lilyGroup);
            
            // Lily pads don't have collision
            const posKey = `${x},${y},${z}`;
            parent.blockPositions[posKey] = { type: 'lily_pad', collision: false };
            
            return lilyGroup;
        }
        
        // Create reed (cattail)
        function createReed(x, y, z, parent) {
            const reedGroup = new THREE.Group();
            reedGroup.position.set(x, y, z);
            
            // Create reed stem and top
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x76A83B });
            const topMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            
            // Stem
            const stem = new THREE.Mesh(blockGeometry, stemMaterial);
            stem.scale.set(0.2, 0.8, 0.2);
            
            // Top
            const top = new THREE.Mesh(blockGeometry, topMaterial);
            top.scale.set(0.3, 0.3, 0.3);
            top.position.y += 0.6;
            
            reedGroup.add(stem);
            reedGroup.add(top);
            parent.add(reedGroup);
            
            // Reeds don't have collision
            const posKey = `${x},${y},${z}`;
            parent.blockPositions[posKey] = { type: 'reed', collision: false };
            
            return reedGroup;
        }
        
        // Create a small pond
        function createPond(x, y, z, parent) {
            // Create a small circular pond
            const pondRadius = 2 + Math.floor(seededRandom(x * z)() * 3);
            
            for (let dx = -pondRadius; dx <= pondRadius; dx++) {
                for (let dz = -pondRadius; dz <= pondRadius; dz++) {
                    const distance = Math.sqrt(dx*dx + dz*dz);
                    if (distance <= pondRadius) {
                        // Create water block
                        createBlock(x + dx, y - 1, z + dz, 'water', parent);
                        const waterKey = `${x + dx},${y - 1},${z + dz}`;
                        parent.blockPositions[waterKey] = { type: 'water' };
                        
                        // Create sand around edge of pond
                        if (distance > pondRadius - 1) {
                            for (let dy = -2; dy < 0; dy++) {
                                createBlock(x + dx, y + dy, z + dz, 'sand', parent);
                                const sandKey = `${x + dx},${y + dy},${z + dz}`;
                                parent.blockPositions[sandKey] = { type: 'sand' };
                            }
                        }
                        
                        // Add lily pads occasionally
                        if (distance < pondRadius - 0.5 && seededRandom(x + dx * 100 + z + dz)() < 0.1) {
                            createWaterLily(x + dx, y, z + dz, parent);
                        }
                    }
                }
            }
        }
        
        // Function to generate terrain with optimization
        function generateTerrain() {
            console.log("Generating terrain with biome:", currentBiome);
            
            // Clear terrain if switching biomes or initial spawn
            if (player.isSpawning) {
                Object.keys(terrain).forEach(chunkKey => {
                    scene.remove(terrain[chunkKey]);
                    delete terrain[chunkKey];
                });
                terrain = {};
            }
            
            // Get player chunk position
            const playerChunkX = Math.floor(player.position.x / chunkSize);
            const playerChunkZ = Math.floor(player.position.z / chunkSize);
            
            // Generate chunks around player
            for (let x = -viewDistance; x <= viewDistance; x++) {
                for (let z = -viewDistance; z <= viewDistance; z++) {
                    const chunkX = playerChunkX + x;
                    const chunkZ = playerChunkZ + z;
                    generateChunk(chunkX, chunkZ);
                }
            }
            
            // If this is initial spawn, check for a safe position
            if (player.isSpawning) {
                // Wait a frame to allow terrain to generate
                setTimeout(() => {
                    // Find a safe position on the ground
                    const groundY = findGroundLevel(player.position.x, player.position.z);
                    if (groundY !== -1) {
                        player.position.y = groundY + 2; // Position 2 blocks above ground
                        camera.position.copy(player.position);
                        camera.position.y += 1.7; // Eye height
                        player.spawned = true;
                    }
                    player.isSpawning = false;
                    console.log("Player spawned at:", player.position);
                }, 100);
            }
        }
        
        // Find ground level at given x,z coordinates
        function findGroundLevel(x, z) {
            // Start from high up and scan down
            for (let y = 100; y >= 0; y--) {
                const posKey = `${Math.floor(x)},${y},${Math.floor(z)}`;
                
                // Check all chunks for this position
                for (const chunk of Object.values(terrain)) {
                    if (chunk.blockPositions[posKey]) {
                        return y + 1; // Return position above the ground
                    }
                }
            }
            
            // No ground found
            return -1;
        }
        
        // Set up scene lighting with improved balance
        function setupLights() {
            // Directional light (sun/moon) with warmer color
            const directionalLight = new THREE.DirectionalLight(0xFFEAC3, 1); // Slightly warm sunlight
            directionalLight.position.set(100, 100, 50);
            scene.add(directionalLight);
            
            // Ambient light - improved for color fidelity
            const ambientLight = new THREE.AmbientLight(0x8097BB, 0.5); // Slightly blue ambient light
            scene.add(ambientLight);
            
            // Store lights for day/night cycle
            dayNightCycle.directionalLight = directionalLight;
            dayNightCycle.ambientLight = ambientLight;
        }
        
        // Handle toggle between game and UI modes
        function toggleUIMode() {
            if (controls.isLocked) {
                controls.unlock();
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('uiModeMessage').style.display = 'block';
            } else {
                controls.lock();
                document.getElementById('uiModeMessage').style.display = 'none';
            }
        }
        
        // Play ambient sound based on biome
        function playAmbientSound(biome) {
            // Pause all ambient sounds first
            Object.values(ambientSounds).forEach(sound => sound.pause());
            
            // Play the selected biome sound on loop
            if (ambientSounds[biome]) {
                ambientSounds[biome].loop = true;
                ambientSounds[biome].volume = 0.3;
                ambientSounds[biome].play().catch(error => console.log("Audio playback error:", error));
            }
        }
        
        // Setup UI interaction
        function setupUI() {
            // Block selection
            document.querySelectorAll('.block-type').forEach(element => {
                element.addEventListener('click', () => {
                    // Remove selected class from all blocks
                    document.querySelectorAll('.block-type').forEach(el => {
                        el.classList.remove('selected');
                    });
                    
                    // Add selected class to clicked block
                    element.classList.add('selected');
                    
                    // Update selected block type
                    selectedBlockType = element.dataset.type;
                });
            });
            
            // Biome selection with proper spawn handling
            document.querySelectorAll('.biome-btn').forEach(element => {
                element.addEventListener('click', () => {
                    console.log("Biome button clicked:", element.dataset.biome);
                    
                    // Remove active class from all biome buttons
                    document.querySelectorAll('.biome-btn').forEach(el => {
                        el.classList.remove('active');
                    });
                    
                    // Add active class to clicked button
                    element.classList.add('active');
                    
                    // Update current biome
                    currentBiome = element.dataset.biome;
                    
                    // Reset player for safe spawning in new biome
                    player.isSpawning = true;
                    
                    // Find a safe spawn location in the new biome
                    findSafeSpawnPoint();
                    
                    // Force regeneration of terrain with new biome
                    Object.keys(terrain).forEach(chunkKey => {
                        scene.remove(terrain[chunkKey]);
                        delete terrain[chunkKey];
                    });
                    terrain = {};
                    generateTerrain();
                    
                    // Update ambient sound
                    if (isGameStarted) {
                        playAmbientSound(currentBiome);
                    }
                    
                    console.log("Changed biome to:", currentBiome);
                });
            });
            
            // Add respawn button
            const respawnButton = document.createElement('button');
            respawnButton.textContent = 'Respawn';
            respawnButton.style.position = 'absolute';
            respawnButton.style.bottom = '10px';
            respawnButton.style.right = '10px';
            respawnButton.style.padding = '8px 12px';
            respawnButton.style.background = '#4CAF50';
            respawnButton.style.color = 'white';
            respawnButton.style.border = 'none';
            respawnButton.style.borderRadius = '4px';
            respawnButton.style.cursor = 'pointer';
            respawnButton.style.zIndex = '1000';
            
            respawnButton.addEventListener('click', () => {
                player.isSpawning = true;
                findSafeSpawnPoint();
                player.velocity.set(0, 0, 0);
                generateTerrain();
            });
            
            document.body.appendChild(respawnButton);
            
            // Prevent context menu on right-click
            document.addEventListener('contextmenu', event => event.preventDefault());
            
            // Add crafting instructions
            const craftingTip = document.createElement('p');
            craftingTip.textContent = 'Press E to open crafting menu';
            document.getElementById('instructions').insertBefore(
                craftingTip, 
                document.getElementById('startButton')
            );
        }
        
        // Add this function to ensure all buttons have proper data-biome attributes
        function checkBiomeButtons() {
            const biomeButtons = document.querySelectorAll('.biome-btn');
            console.log("Biome buttons found:", biomeButtons.length);
            
            biomeButtons.forEach(button => {
                console.log(`Button: ${button.textContent}, data-biome: ${button.dataset.biome}`);
                
                // If button doesn't have data-biome attribute, try to set it based on its text content
                if (!button.dataset.biome) {
                    const text = button.textContent.toLowerCase().trim();
                    if (text === 'forest' || text === 'desert' || text === 'mountains' || text === 'plains') {
                        button.dataset.biome = text;
                        console.log(`Fixed missing data-biome attribute on button: ${text}`);
                    }
                }
            });
        }
        
        // Initialize the game with optimized settings
        function init() {
            // Create Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 15, 45); // Closer fog for better performance and hide pop-in
            
            // First find a safe spawn point based on biome
            findSafeSpawnPoint();
            
            // Set up camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(player.position);
            
            // Set up renderer with performance optimizations
            renderer = new THREE.WebGLRenderer({ 
                antialias: false,
                alpha: false, // No need for alpha in a minecraft-style game
                preserveDrawingBuffer: false // Better performance
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB, 1);
            renderer.shadowMap.enabled = false;
            document.body.appendChild(renderer.domElement);
            
            // Create UI mode message
            const uiModeMessage = document.createElement('div');
            uiModeMessage.id = 'uiModeMessage';
            uiModeMessage.style.position = 'absolute';
            uiModeMessage.style.top = '10px';
            uiModeMessage.style.left = '50%';
            uiModeMessage.style.transform = 'translateX(-50%)';
            uiModeMessage.style.background = 'rgba(0,0,0,0.7)';
            uiModeMessage.style.color = 'white';
            uiModeMessage.style.padding = '10px';
            uiModeMessage.style.borderRadius = '5px';
            uiModeMessage.style.zIndex = '1000';
            uiModeMessage.style.display = 'none';
            uiModeMessage.innerHTML = 'UI Mode Active - Click game to resume or press Tab';
            document.body.appendChild(uiModeMessage);
            
            // Set up controls
            controls = new THREE.PointerLockControls(camera, document.body);
            document.getElementById('startButton').addEventListener('click', () => {
                try {
                    controls.lock();
                    console.log("Controls locked");
                } catch (e) {
                    console.error("Error locking controls:", e);
                }
            });
            
            controls.addEventListener('lock', () => {
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('uiModeMessage').style.display = 'none';
                isGameStarted = true;
                
                // Start playing ambient sound based on biome
                try {
                    playAmbientSound(currentBiome);
                } catch (e) {
                    console.error("Error playing sound:", e);
                }
            });
            
            controls.addEventListener('unlock', () => {
                if (!isGameStarted) {
                    document.getElementById('instructions').style.display = 'flex';
                }
            });
            
            // Add Tab key to toggle UI mode
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && isGameStarted) {
                    controls.unlock();
                    document.getElementById('instructions').style.display = 'flex';
                    isGameStarted = false;
                    
                    // Pause all ambient sounds
                    try {
                        Object.values(ambientSounds).forEach(sound => sound.pause());
                    } catch (e) {
                        console.error("Error pausing sounds:", e);
                    }
                }
                
                if (event.key === 'Tab' && isGameStarted) {
                    event.preventDefault(); // Prevent tab from changing focus
                    toggleUIMode();
                }
                
                console.log("Key pressed:", event.key);
            });
            
            // Update instructions to include Tab key information
            const instructionsElement = document.getElementById('instructions');
            const tabTip = document.createElement('p');
            tabTip.textContent = 'Press TAB to toggle mouse cursor for UI interaction';
            instructionsElement.insertBefore(tabTip, document.getElementById('startButton'));
            
            console.log("Setting up lighting");
            // Add lights
            setupLights();
            
            console.log("Generating terrain");
            // Generate initial terrain
            generateTerrain();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseClick);
            
            // Setup UI interaction
            setupUI();
            
            // Check biome buttons
            setTimeout(checkBiomeButtons, 500); // Give DOM time to fully load
            
            // Start animation loop
            animate();
            console.log("Game initialized with biome:", currentBiome);
            
            // Initialize crafting system after DOM is loaded
            setTimeout(() => {
                initCraftingSystem();
                // Give player some starting resources
                playerInventory.wood = 5;
                updateInventoryDisplay();
            }, 1000);
            
            // Initialize the highlight box after scene is created
            initHighlightBox();
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle keyboard input
        function onKeyDown(event) {
            keyboard[event.key.toLowerCase()] = true;
            
            // Alternative movement keys for trackpad users
            if (event.key === 'ArrowUp') keyboard['w'] = true;
            if (event.key === 'ArrowDown') keyboard['s'] = true;
            if (event.key === 'ArrowLeft') keyboard['a'] = true;
            if (event.key === 'ArrowRight') keyboard['d'] = true;
        }
        
        function onKeyUp(event) {
            keyboard[event.key.toLowerCase()] = false;
            
            // Alternative movement keys for trackpad users
            if (event.key === 'ArrowUp') keyboard['w'] = false;
            if (event.key === 'ArrowDown') keyboard['s'] = false;
            if (event.key === 'ArrowLeft') keyboard['a'] = false;
            if (event.key === 'ArrowRight') keyboard['d'] = false;
        }
        
        // Handle mouse clicks for block manipulation
        function onMouseClick(event) {
            if (!isGameStarted) return;
            
            // Cast ray from camera
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            
            // Find all intersections with terrain chunks
            const intersections = [];
            Object.values(terrain).forEach(chunk => {
                // We need to check each block in the chunk
                for (const [posKey, blockData] of Object.entries(chunk.blockPositions)) {
                    const [x, y, z] = posKey.split(',').map(Number);
                    const blockBox = new THREE.Box3(
                        new THREE.Vector3(x - 0.5, y - 0.5, z - 0.5),
                        new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5)
                    );
                    
                    // Check for intersection with this block
                    const intersect = raycaster.ray.intersectBox(blockBox, new THREE.Vector3());
                    if (intersect) {
                        intersections.push({
                            distance: intersect.distanceTo(camera.position),
                            point: intersect.clone(),
                            normal: raycaster.ray.direction.clone().negate(),
                            blockPosition: { x, y, z },
                            chunk: chunk,
                            blockData: blockData
                        });
                    }
                }
            });
            
            // Sort by distance
            intersections.sort((a, b) => a.distance - b.distance);
            
            if (intersections.length > 0) {
                const intersection = intersections[0];
                
                if (event.button === 0) {
                    // Left click - remove block
                    removeBlock(intersection);
                } else if (event.button === 2) {
                    // Right click - place block
                    placeBlock(intersection);
                }
            }
        }
        
        // Remove a block
        function removeBlock(intersection) {
            const { chunk, blockPosition } = intersection;
            const posKey = `${blockPosition.x},${blockPosition.y},${blockPosition.z}`;
            
            // Get block type before deletion
            const blockData = chunk.blockPositions[posKey];
            if (blockData) {
                const blockType = blockData.type;
                
                // Map block type to inventory resource
                let resource = blockType;
                
                // Check for special types (for example, wooden_pickaxe stays as is)
                if (blockType === 'grass') resource = 'grass';
                else if (blockType === 'stone') resource = 'stone';
                else if (blockType === 'dirt') resource = 'dirt';
                else if (blockType === 'sand') resource = 'sand';
                else if (blockType === 'wood') resource = 'wood';
                else if (blockType.includes('sand_')) resource = 'sand'; // All sand variants give sand
                
                // Add to inventory
                playerInventory[resource] = (playerInventory[resource] || 0) + 1;
                
                // Update inventory display
                updateInventoryDisplay();
                
                // Remove block from chunk data
                delete chunk.blockPositions[posKey];
                
                // Find and remove the actual block mesh from the scene
                // We need to search through all the children of the chunk group
                for (let i = chunk.children.length - 1; i >= 0; i--) {
                    const blockMesh = chunk.children[i];
                    // Check if this mesh is at the same position as our target block
                    if (Math.abs(blockMesh.position.x - blockPosition.x) < 0.1 && 
                        Math.abs(blockMesh.position.y - blockPosition.y) < 0.1 && 
                        Math.abs(blockMesh.position.z - blockPosition.z) < 0.1) {
                        // Remove this mesh from the scene
                        chunk.remove(blockMesh);
                        break; // We found and removed the block, so stop searching
                    }
                }
                
                console.log(`Removed block of type ${blockType} at ${posKey}, added to inventory`);
            } else {
                console.log("No block data found at position:", posKey);
            }
        }
        
        // Place a block
        function placeBlock(intersection) {
            const { point, normal, chunk } = intersection;
            const x = Math.round(point.x + normal.x * 0.5);
            const y = Math.round(point.y + normal.y * 0.5);
            const z = Math.round(point.z + normal.z * 0.5);
            
            // Don't place inside player
            const playerPos = camera.position;
            if (Math.abs(x - playerPos.x) < 1 && 
                Math.abs(y - playerPos.y) < 2 && 
                Math.abs(z - playerPos.z) < 1) {
                return;
            }
            
            // Check if we have the resource in inventory
            if (playerInventory[selectedBlockType] && playerInventory[selectedBlockType] > 0) {
                // Deduct resource from inventory
                playerInventory[selectedBlockType]--;
                
                // Update inventory display
                updateInventoryDisplay();
                
                // Add block to chunk data
                const posKey = `${x},${y},${z}`;
                if (!chunk.blockPositions[posKey]) {
                    chunk.blockPositions[posKey] = {
                        type: selectedBlockType,
                        index: Object.keys(chunk.blockPositions).length
                    };
                    
                    // Regenerate terrain for simplicity
                    generateTerrain();
                }
            } else {
                console.log("Not enough resources to place this block");
            }
        }
        
        // Update player physics (optimized) with falling detection
        function updatePlayer(delta) {
            if (!isGameStarted) return;
            
            // Check if player fell out of the world
            if (player.position.y < -10) {
                console.log("Player fell out of the world, respawning...");
                // Reset player position to safe spawn point
                player.isSpawning = true;
                findSafeSpawnPoint();
                generateTerrain();
                player.velocity.set(0, 0, 0);
                return;
            }
            
            // Apply gravity
            if (!isPlayerOnGround()) {
                player.velocity.y -= 20 * delta; // Gravity
            } else if (player.velocity.y < 0) {
                player.velocity.y = 0;
            }
            
            // Cap falling speed
            if (player.velocity.y < -30) {
                player.velocity.y = -30;
            }
            
            // Jump
            if ((keyboard[' '] || keyboard['arrowup']) && isPlayerOnGround()) {
                player.velocity.y = 8;
            }
            
            // Movement direction based on camera orientation
            const moveDirection = new THREE.Vector3();
            const cameraDirection = controls.getDirection(new THREE.Vector3());
            cameraDirection.y = 0; // Keep movement on horizontal plane
            cameraDirection.normalize();
            
            const speedMultiplier = keyboard.shift ? 1.5 : 1.0; // Sprint with shift
            
            if (keyboard['w'] || keyboard['arrowup']) {
                moveDirection.add(cameraDirection);
            }
            if (keyboard['s'] || keyboard['arrowdown']) {
                moveDirection.sub(cameraDirection);
            }
            
            const cameraSide = new THREE.Vector3();
            cameraSide.crossVectors(camera.up, cameraDirection).normalize();
            
            if (keyboard['a'] || keyboard['arrowleft']) {
                moveDirection.add(cameraSide);
            }
            if (keyboard['d'] || keyboard['arrowright']) {
                moveDirection.sub(cameraSide);
            }
            
            // Apply movement with collision detection
            if (moveDirection.length() > 0) {
                moveDirection.normalize();
                moveDirection.multiplyScalar(5 * speedMultiplier * delta); // Speed
                movePlayerWithCollision(moveDirection);
            }
            
            // Apply vertical velocity
            movePlayerWithCollision(new THREE.Vector3(0, player.velocity.y * delta, 0));
            
            // Update camera position
            camera.position.copy(player.position);
            camera.position.y += 1.7; // Player height (eyes)
            
            // Check if terrain needs to be updated
            const playerChunkX = Math.floor(player.position.x / chunkSize);
            const playerChunkZ = Math.floor(player.position.z / chunkSize);
            
            if (playerChunkX !== player.lastChunkX || playerChunkZ !== player.lastChunkZ) {
                player.lastChunkX = playerChunkX;
                player.lastChunkZ = playerChunkZ;
                generateTerrain();
            }
        }
        
        // Check if player is on ground
        function isPlayerOnGround() {
            const pos = player.position.clone();
            pos.y -= 0.1; // Check slightly below feet
            
            return isPositionSolid(pos);
        }
        
        // Move player with collision detection
        function movePlayerWithCollision(moveVector) {
            // X-axis movement
            if (moveVector.x !== 0) {
                player.position.x += moveVector.x;
                
                // Check for collision in X direction
                if (isPlayerColliding()) {
                    player.position.x -= moveVector.x;
                }
            }
            
            // Y-axis movement
            if (moveVector.y !== 0) {
                player.position.y += moveVector.y;
                
                // Check for collision in Y direction
                if (isPlayerColliding()) {
                    player.position.y -= moveVector.y;
                    player.velocity.y = 0;
                }
            }
            
            // Z-axis movement
            if (moveVector.z !== 0) {
                player.position.z += moveVector.z;
                
                // Check for collision in Z direction
                if (isPlayerColliding()) {
                    player.position.z -= moveVector.z;
                }
            }
        }
        
        // Check if player is colliding with blocks
        function isPlayerColliding() {
            // Player collision box
            const playerBox = new THREE.Box3(
                new THREE.Vector3(
                    player.position.x - 0.3,
                    player.position.y,
                    player.position.z - 0.3
                ),
                new THREE.Vector3(
                    player.position.x + 0.3,
                    player.position.y + 1.7,
                    player.position.z + 0.3
                )
            );
            
            // Check each corner of the player box
            for (let x = -1; x <= 1; x += 2) {
                for (let y = 0; y <= 1; y += 1) {
                    for (let z = -1; z <= 1; z += 2) {
                        const checkPos = new THREE.Vector3(
                            player.position.x + x * 0.3,
                            player.position.y + y * 1.7,
                            player.position.z + z * 0.3
                        );
                        
                        if (isPositionSolid(checkPos)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Check if a position is inside a solid block
        function isPositionSolid(position) {
            const blockX = Math.floor(position.x + 0.5);
            const blockY = Math.floor(position.y);
            const blockZ = Math.floor(position.z + 0.5);
            const posKey = `${blockX},${blockY},${blockZ}`;
            
            // Check all chunks
            for (const chunk of Object.values(terrain)) {
                if (chunk.blockPositions[posKey]) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Update day/night cycle with realistic sky colors
        function updateDayNightCycle(delta) {
            dayNightCycle.time += delta;
            
            if (dayNightCycle.time > dayNightCycle.duration) {
                dayNightCycle.time = 0;
                dayNightCycle.isDay = !dayNightCycle.isDay;
            }
            
            // Calculate cycle progress (0 to 1)
            const cycleProgress = (dayNightCycle.time / dayNightCycle.duration);
            
            // Day-night transition based on cycle progress
            if (dayNightCycle.isDay) {
                // Day colors with better transitions
                const lightIntensity = 1.0 - 0.7 * cycleProgress; // Dim as day progresses
                dayNightCycle.directionalLight.intensity = lightIntensity;
                
                // Warmer morning, cooler evening
                if (cycleProgress < 0.5) {
                    // Morning - warmer light
                    dayNightCycle.directionalLight.color.setHex(0xFFEAC3);
                } else {
                    // Evening - cooler light
                    dayNightCycle.directionalLight.color.setHex(0xE0E8FF);
                }
                
                // Sky color - gradually shift from bright blue to darker blue
                const skyColor = new THREE.Color(
                    0.6 - 0.3 * cycleProgress,
                    0.85 - 0.4 * cycleProgress,
                    0.99 - 0.3 * cycleProgress
                );
                scene.background = skyColor;
                scene.fog.color = skyColor;
            } else {
                // Night colors
                const lightIntensity = 0.2 + 0.8 * cycleProgress; // Brighten as night progresses
                dayNightCycle.directionalLight.intensity = lightIntensity;
                
                // Cooler night, warmer pre-dawn
                if (cycleProgress < 0.7) {
                    // Night - blue light
                    dayNightCycle.directionalLight.color.setHex(0xA0B0FF);
                } else {
                    // Pre-dawn - warmer light
                    dayNightCycle.directionalLight.color.setHex(0xFFD8A0);
                }
                
                // Sky color - gradually shift from dark blue to morning blue
                const skyColor = new THREE.Color(
                    0.05 + 0.55 * cycleProgress,
                    0.05 + 0.80 * cycleProgress,
                    0.15 + 0.84 * cycleProgress
                );
                scene.background = skyColor;
                scene.fog.color = skyColor;
            }
        }
        
        // Main animation loop with FPS optimization
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1); // Cap delta time to prevent jumps
            
            // Update player physics
            updatePlayer(delta);
            
            // Update day/night cycle
            updateDayNightCycle(delta);
            
            // Update block highlighting
            updateBlockHighlight();
            
            // Only render if the game is active
            if (isGameStarted) {
                renderer.render(scene, camera);
            }
            
            // Update block selector based on inventory changes
            updateBlockSelector();
        }

        // Initialize the game when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            console.log("DOM loaded, initializing game");
            try {
                init();
            } catch (e) {
                console.error("Error initializing game:", e);
            }
        });

        // Initialize crafting system
        function initCraftingSystem() {
            // Create crafting grid slots
            const craftingGridElement = document.getElementById('craftingGrid');
            craftingGridElement.innerHTML = '';
            
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    const slot = document.createElement('div');
                    slot.className = 'craftingSlot';
                    slot.dataset.x = x;
                    slot.dataset.y = y;
                    slot.addEventListener('click', () => handleCraftingSlotClick(x, y));
                    craftingGridElement.appendChild(slot);
                }
            }
            
            // Create inventory slots
            updateInventoryGrid();
            
            // Set up crafting buttons
            document.getElementById('craftBtn').addEventListener('click', handleCraft);
            document.getElementById('clearBtn').addEventListener('click', clearCraftingGrid);
            document.getElementById('closeCraftingBtn').addEventListener('click', toggleCraftingUI);
            
            // Create simple inventory display (always visible)
            updateInventoryDisplay();
            
            // Add keyboard shortcut for crafting
            document.addEventListener('keydown', (event) => {
                if (event.key === 'e' && isGameStarted) {
                    event.preventDefault();
                    toggleCraftingUI();
                }
            });
        }
        
        // Toggle crafting UI visibility
        function toggleCraftingUI() {
            isCraftingOpen = !isCraftingOpen;
            document.getElementById('craftingUI').style.display = isCraftingOpen ? 'block' : 'none';
            
            if (isCraftingOpen) {
                controls.unlock();
                // Update inventory when opening
                updateInventoryGrid();
            } else {
                // Clear any selected item
                selectedInventorySlot = null;
                document.body.style.cursor = 'default';
                // Return to game
                controls.lock();
            }
        }
        
        // Update the inventory grid in the crafting UI
        function updateInventoryGrid() {
            const inventoryGridElement = document.getElementById('inventoryGrid');
            inventoryGridElement.innerHTML = '';
            
            // Only show items with quantity > 0
            const inventoryItems = Object.entries(playerInventory)
                .filter(([item, quantity]) => quantity > 0);
            
            for (const [item, quantity] of inventoryItems) {
                const slot = document.createElement('div');
                slot.className = 'inventorySlot';
                slot.dataset.item = item;
                
                const itemElement = document.createElement('div');
                itemElement.className = 'slotItem';
                
                // Use custom render function if available, otherwise use simple color
                if (itemProperties[item].render) {
                    itemProperties[item].render(itemElement);
                } else {
                    itemElement.style.backgroundColor = itemProperties[item].color;
                }
                
                const quantityElement = document.createElement('div');
                quantityElement.className = 'slotQuantity';
                quantityElement.textContent = quantity;
                
                slot.appendChild(itemElement);
                slot.appendChild(quantityElement);
                slot.addEventListener('click', () => handleInventorySlotClick(item));
                
                inventoryGridElement.appendChild(slot);
            }
        }
        
        // Update the simple inventory display (always visible)
        function updateInventoryDisplay() {
            const inventoryDisplayElement = document.getElementById('inventoryDisplay');
            inventoryDisplayElement.innerHTML = '';
            
            // Show all available materials in the player's inventory
            // Get all items that the player has at least one of
            const availableItems = Object.entries(playerInventory)
                .filter(([item, quantity]) => quantity > 0)
                .map(([item]) => item);
            
            // Materials to prioritize at the beginning of the display
            const priorityItems = ['wood', 'stone', 'dirt', 'grass', 'sand', 'snow'];
            
            // Sort items so priority items come first, then alphabetical
            const sortedItems = availableItems.sort((a, b) => {
                const aIndex = priorityItems.indexOf(a);
                const bIndex = priorityItems.indexOf(b);
                
                // If both are priority items, sort by priority list order
                if (aIndex >= 0 && bIndex >= 0) {
                    return aIndex - bIndex;
                }
                // If only a is a priority item, it comes first
                if (aIndex >= 0) return -1;
                // If only b is a priority item, it comes first
                if (bIndex >= 0) return 1;
                // Otherwise alphabetical
                return a.localeCompare(b);
            });
            
            // Add items to the display
            for (const item of sortedItems) {
                // Skip tools and crafted items from the main display
                if (['wooden_pickaxe', 'stone_pickaxe', 'wooden_axe', 'stone_axe', 'crafting_table'].includes(item)) {
                    continue;
                }
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'invItem';
                
                const icon = document.createElement('div');
                icon.className = 'invIcon';
                
                // Make sure we have valid item properties
                if (!itemProperties[item]) {
                    // Add missing item properties
                    itemProperties[item] = {
                        color: getDefaultColorForItem(item),
                        name: formatItemName(item)
                    };
                }
                
                // Use custom render function if available for smaller icon
                if (itemProperties[item].render) {
                    icon.style.position = "relative";
                    icon.style.overflow = "hidden";
                    
                    const miniItem = document.createElement('div');
                    miniItem.style.transformOrigin = "top left";
                    miniItem.style.transform = "scale(0.5)";
                    miniItem.style.width = "40px";
                    miniItem.style.height = "40px";
                    miniItem.style.position = "absolute";
                    
                    itemProperties[item].render(miniItem);
                    icon.appendChild(miniItem);
                } else {
                    icon.style.backgroundColor = itemProperties[item].color;
                }
                
                const count = document.createElement('span');
                count.textContent = playerInventory[item];
                
                itemDiv.appendChild(icon);
                itemDiv.appendChild(count);
                inventoryDisplayElement.appendChild(itemDiv);
            }
        }
        
        // Handle click on crafting slot
        function handleCraftingSlotClick(x, y) {
            if (!selectedInventorySlot) return;
            
            // Check if we have enough of the resource
            if (playerInventory[selectedInventorySlot] > 0) {
                // Place selected item in crafting grid
                craftingGrid[y][x] = selectedInventorySlot;
                
                // Temporarily decrease inventory count (will be restored if crafting is cleared)
                playerInventory[selectedInventorySlot]--;
                
                // Update inventory display
                updateInventoryGrid();
                updateInventoryDisplay();
                
                // Update UI
                updateCraftingGridUI();
                
                // Check for matching recipe
                checkForRecipeMatch();
            }
            
            // Reset selection
            selectedInventorySlot = null;
            
            // Clear selection highlight
            document.querySelectorAll('.inventorySlot').forEach(slot => {
                slot.style.border = '2px solid #777';
            });
        }
        
        // Handle click on inventory slot
        function handleInventorySlotClick(item) {
            // Select or deselect item
            selectedInventorySlot = selectedInventorySlot === item ? null : item;
            
            // Update UI to show selection
            document.querySelectorAll('.inventorySlot').forEach(slot => {
                slot.style.border = slot.dataset.item === selectedInventorySlot 
                    ? '2px solid #ffff00' 
                    : '2px solid #777';
            });
            
            // Add cursor effect to show selected item
            if (selectedInventorySlot) {
                document.body.style.cursor = 'grabbing';
            } else {
                document.body.style.cursor = 'default';
            }
        }
        
        // Update crafting grid UI
        function updateCraftingGridUI() {
            const slots = document.querySelectorAll('.craftingSlot');
            
            slots.forEach(slot => {
                const x = parseInt(slot.dataset.x);
                const y = parseInt(slot.dataset.y);
                const item = craftingGrid[y][x];
                
                // Clear slot
                slot.innerHTML = '';
                slot.classList.remove('filled');
                
                // Add item if exists
                if (item) {
                    const itemElement = document.createElement('div');
                    itemElement.className = 'slotItem';
                    
                    // Use custom render function if available
                    if (itemProperties[item].render) {
                        itemProperties[item].render(itemElement);
                    } else {
                        itemElement.style.backgroundColor = itemProperties[item].color;
                    }
                    
                    slot.appendChild(itemElement);
                    slot.classList.add('filled');
                }
            });
        }
        
        // Check if current crafting grid matches a recipe
        function checkForRecipeMatch() {
            currentRecipeResult = null;
            const craftBtn = document.getElementById('craftBtn');
            const resultSlot = document.getElementById('resultSlot');
            
            // Clear result slot
            resultSlot.innerHTML = '';
            
            // Check each recipe
            for (const recipe of recipes) {
                if (comparePattern(craftingGrid, recipe.pattern)) {
                    currentRecipeResult = recipe.result;
                    
                    // Show result
                    const resultItem = document.createElement('div');
                    resultItem.className = 'slotItem';
                    
                    // Use custom render function if available
                    if (itemProperties[recipe.result.item].render) {
                        itemProperties[recipe.result.item].render(resultItem);
                    } else {
                        resultItem.style.backgroundColor = itemProperties[recipe.result.item].color;
                    }
                    
                    const resultQuantity = document.createElement('div');
                    resultQuantity.className = 'slotQuantity';
                    resultQuantity.textContent = recipe.result.quantity;
                    
                    resultSlot.appendChild(resultItem);
                    resultSlot.appendChild(resultQuantity);
                    
                    // Enable craft button
                    craftBtn.disabled = false;
                    return;
                }
            }
            
            // No match found, disable craft button
            craftBtn.disabled = true;
        }
        
        // Compare crafting grid pattern with recipe pattern
        function comparePattern(grid, pattern) {
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    // Skip if pattern position is null (doesn't matter)
                    if (pattern[y][x] !== null && grid[y][x] !== pattern[y][x]) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        // Handle crafting button click
        function handleCraft() {
            if (!currentRecipeResult) return;
            
            // Add crafted item to inventory
            playerInventory[currentRecipeResult.item] += currentRecipeResult.quantity;
            
            // Consume ingredients from inventory
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    const item = craftingGrid[y][x];
                    if (item) {
                        playerInventory[item]--;
                    }
                }
            }
            
            // Clear crafting grid
            clearCraftingGrid();
            
            // Update UI
            updateInventoryGrid();
            updateInventoryDisplay();
        }
        
        // Clear crafting grid
        function clearCraftingGrid() {
            // Return items from grid to inventory
            for (let y = 0; y < 3; y++) {
                for (let x = 0; x < 3; x++) {
                    const item = craftingGrid[y][x];
                    if (item) {
                        playerInventory[item]++;
                    }
                }
            }
            
            // Reset grid
            craftingGrid = [
                [null, null, null],
                [null, null, null],
                [null, null, null]
            ];
            
            // Update UI
            updateCraftingGridUI();
            updateInventoryGrid();
            updateInventoryDisplay();
            
            // Clear result
            currentRecipeResult = null;
            document.getElementById('resultSlot').innerHTML = '';
            document.getElementById('craftBtn').disabled = true;
            
            // Reset cursor
            document.body.style.cursor = 'default';
        }

        // Add crafting tools to block selector
        function addCraftedItemsToBlockSelector() {
            const blockSelector = document.getElementById('blockSelector');
            
            // Add crafted items that can be placed
            const placeableItems = ['crafting_table'];
            
            for (const item of placeableItems) {
                // Check if the item is already in the selector
                if (!document.querySelector(`.block-type[data-type="${item}"]`)) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'block-type';
                    itemDiv.dataset.type = item;
                    
                    const preview = document.createElement('div');
                    preview.className = 'block-preview';
                    preview.style.backgroundColor = itemProperties[item].color;
                    
                    const span = document.createElement('span');
                    span.textContent = itemProperties[item].name;
                    
                    itemDiv.appendChild(preview);
                    itemDiv.appendChild(span);
                    
                    itemDiv.addEventListener('click', () => {
                        // Remove selected class from all blocks
                        document.querySelectorAll('.block-type').forEach(el => {
                            el.classList.remove('selected');
                        });
                        
                        // Add selected class to clicked block
                        itemDiv.classList.add('selected');
                        
                        // Update selected block type
                        selectedBlockType = item;
                    });
                    
                    blockSelector.appendChild(itemDiv);
                }
            }
        }
        
        // Automatically update block selector when inventory changes
        function updateBlockSelector() {
            // Update crafting items
            addCraftedItemsToBlockSelector();
            
            // Update visibility based on inventory
            document.querySelectorAll('.block-type').forEach(blockType => {
                const type = blockType.dataset.type;
                // If this is a craftable item, show it only if we have it
                if (['crafting_table', 'wooden_pickaxe', 'stone_pickaxe'].includes(type)) {
                    blockType.style.display = playerInventory[type] > 0 ? 'flex' : 'none';
                }
            });
        }

        // Helper function to get a default color for items that may not be defined
        function getDefaultColorForItem(item) {
            // Default colors for common materials
            const defaultColors = {
                grass: "#3A9D23",
                dirt: "#59472B",
                stone: "#666666",
                sand: "#DBC681",
                sand_light: "#E8D9A0",
                sand_red: "#C2A477",
                sand_gold: "#D4B16A",
                sand_dark: "#B49B6C",
                wood: "#52341D",
                snow: "#F5F5F5",
                water: "#1A45A5",
                cactus: "#2D742F",
                stick: "#8B5A2B"
            };
            
            return defaultColors[item] || "#AAAAAA"; // Default gray for unknown items
        }

        // Helper function to format item name for display
        function formatItemName(item) {
            return item.split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        // Add this new function
        function initHighlightBox() {
            // Create wireframe geometry for the highlight box
            const geometry = new THREE.BoxGeometry(1.01, 1.01, 1.01);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });
            
            highlightBox = new THREE.LineSegments(edges, material);
            highlightBox.visible = false;
            scene.add(highlightBox);
            
            console.log("Highlight box initialized");
        }

        // Add this new function to handle the highlight updates
        function updateBlockHighlight() {
            if (!isGameStarted || isCraftingOpen) {
                // Hide highlight when game is not started or crafting UI is open
                if (highlightBox) highlightBox.visible = false;
                return;
            }
            
            // Cast ray from camera
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            
            // Find all intersections with terrain chunks
            const intersections = [];
            Object.values(terrain).forEach(chunk => {
                // We need to check each block in the chunk
                for (const [posKey, blockData] of Object.entries(chunk.blockPositions)) {
                    const [x, y, z] = posKey.split(',').map(Number);
                    const blockBox = new THREE.Box3(
                        new THREE.Vector3(x - 0.5, y - 0.5, z - 0.5),
                        new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5)
                    );
                    
                    // Check for intersection with this block
                    const intersect = raycaster.ray.intersectBox(blockBox, new THREE.Vector3());
                    if (intersect) {
                        intersections.push({
                            distance: intersect.distanceTo(camera.position),
                            point: intersect.clone(),
                            normal: raycaster.ray.direction.clone().negate(),
                            blockPosition: { x, y, z },
                            chunk: chunk,
                            blockData: blockData
                        });
                    }
                }
            });
            
            // Sort by distance
            intersections.sort((a, b) => a.distance - b.distance);
            
            if (intersections.length > 0 && intersections[0].distance < 5) {
                // We have a target block in range
                const target = intersections[0];
                
                // Position the highlight box at the target block position
                highlightBox.position.set(
                    target.blockPosition.x,
                    target.blockPosition.y,
                    target.blockPosition.z
                );
                
                // Change highlight color based on action (left click = break, right click = place)
                if (keyboard.shift) {
                    // Special color when shift is held (could indicate special action)
                    highlightBox.material.color.setHex(0xff3333);
                } else {
                    // Regular highlight
                    highlightBox.material.color.setHex(0xffffff);
                }
                
                // Make highlight visible
                highlightBox.visible = true;
                
                // Optional: pulse effect for the highlight
                const pulse = 0.8 + 0.2 * Math.sin(performance.now() * 0.005);
                highlightBox.material.opacity = pulse;
            } else {
                // No target block, hide the highlight
                highlightBox.visible = false;
            }
        }

        // Optional: Add highlight color change on mouse down for better feedback
        document.addEventListener('mousedown', function(event) {
            if (!highlightBox || !highlightBox.visible) return;
            
            if (event.button === 0) {
                // Left click - breaking block
                highlightBox.material.color.setHex(0xff3333); // Red for breaking
            } else if (event.button === 2) {
                // Right click - placing block
                highlightBox.material.color.setHex(0x33ff33); // Green for placing
            }
        });

        document.addEventListener('mouseup', function() {
            if (!highlightBox || !highlightBox.visible) return;
            // Reset color on mouse up
            highlightBox.material.color.setHex(0xffffff);
        });
    </script>
</body>
</html>

